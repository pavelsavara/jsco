{"version":3,"file":"index.js","sources":["https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce//assert.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce//fetch-like.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce//streaming.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/checks/has-wasm.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/errors/unsupported.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/errors/deferror.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/api/api.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/transducers/reduced.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/transducers/iterator.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/transducers/ensure.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/checks/implements-function.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/leb128/index.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/transducers-binary/base64.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/transducers/compr.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/@thi.ng/leb128/binary.js","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/values.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/export.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/alias.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/index.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/otherSection.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/module.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/coreInstance.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/instance.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/type.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/canon.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/r/import.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/binding/cache.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/binding/to-js.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/binding/to-abi.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/les/just-camel-case/index.mjs","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/component-types.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/component-instances.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/core-module.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/core-instance.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/core-functions.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/core-exports.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/component-functions.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/component-exports.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/component-imports.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/context.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/ver/index.ts","https://raw.githubusercontent.com/pavelsavara/jsco/258ed845f5354b8e4ac7310ddf41107c7cc11bce/.ts"],"sourcesContent":["// TODO inline rollup macro\nexport function jsco_assert(condition, messageFactory) {\n    if (condition)\n        return;\n    const message = 'Assert failed: ' + (typeof messageFactory === 'function'\n        ? messageFactory()\n        : messageFactory);\n    throw new Error(message);\n}\n// TODO figure out how to get jest to use virtual modules\nexport let configuration = 'Debug';\nexport let isDebug = false;\nexport function setConfiguration(value) {\n    configuration = value;\n    isDebug = value === 'Debug';\n}\nexport function debugStack(src, target, position) {\n    if (!isDebug)\n        return;\n    const orig = src['debugStack'] ?? [];\n    target['debugStack'] = [position, ...(orig)];\n}\n//# sourceMappingURL=assert.js.map","const isNode = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';\nexport function fetchLike(url) {\n    const isFileUrl = url.startsWith('file://');\n    const isHttpUrl = url.startsWith('https://') || url.startsWith('http://');\n    if (isNode && (isFileUrl || !isHttpUrl)) {\n        return import('fs/promises').then((fs) => {\n            return fs.readFile(url);\n        });\n    }\n    if (typeof globalThis.fetch !== 'function') {\n        throw new Error('globalThis.fetch is not a function');\n    }\n    return globalThis.fetch(url);\n}\nexport async function getBodyIfResponse(input) {\n    if ('length' in input || 'getReader' in input) {\n        return input;\n    }\n    if ('body' in input) {\n        return getBodyIfResponse(input.body);\n    }\n    if ('then' in input) {\n        return getBodyIfResponse(await input);\n    }\n    throw new Error('I got ' + typeof input);\n}\n//# sourceMappingURL=fetch-like.js.map","// adapted from https://github.com/yskszk63/stream-wasm-parser by yusuke suzuki under MIT License\nexport function newSource(items) {\n    if ('getReader' in items) {\n        return new StreamSource(items);\n    }\n    else {\n        return new ArraySource(items);\n    }\n}\nclass StreamSource {\n    total;\n    bpos;\n    buf;\n    reader;\n    constructor(stream) {\n        this.total = 0;\n        this.bpos = 0;\n        this.buf = null;\n        this.reader = stream.getReader();\n    }\n    get pos() {\n        return this.total;\n    }\n    async fill(need) {\n        if (this.buf === null || this.buf.length - this.bpos < 1) {\n            const result = await this.reader.read();\n            if (result.done) {\n                return 'EOF';\n            }\n            this.buf = result.value;\n            this.bpos = 0;\n        }\n        const start = this.bpos;\n        const len = Math.min(this.buf.length - start, need);\n        this.bpos += len;\n        this.total += len;\n        return this.buf.subarray(start, start + len);\n    }\n    async readAvailable(limit) {\n        if (this.buf === null || this.buf.length - this.bpos < 1) {\n            const result = await this.reader.read();\n            if (result.done) {\n                return null;\n            }\n            this.buf = result.value;\n            this.bpos = 0;\n        }\n        const start = this.bpos;\n        const len = Math.min(this.buf.length - start, limit);\n        this.bpos += len;\n        this.total += len;\n        return this.buf.subarray(start, start + len);\n    }\n    async read(eof) {\n        const maybebuf = await this.fill(1);\n        if (maybebuf === 'EOF') {\n            if (eof === true) {\n                return null;\n            }\n            else {\n                throw new Error('unexpected EOF.');\n            }\n        }\n        return maybebuf[0];\n    }\n    async readExact(n) {\n        const r = new Uint8Array(n);\n        let rest = n;\n        while (rest > 0) {\n            const maybebuf = await this.fill(rest);\n            if (maybebuf === 'EOF') {\n                throw new Error('unexpected EOF.');\n            }\n            r.set(maybebuf, r.length - rest);\n            rest -= maybebuf.length;\n        }\n        return r;\n    }\n    async skip(n) {\n        if (n < 0) {\n            throw new Error('illegal argument.');\n        }\n        let rest = n;\n        while (rest > 0) {\n            const maybebuf = await this.fill(rest);\n            if (maybebuf === 'EOF') {\n                throw new Error('unexpected EOF.');\n            }\n            rest -= maybebuf.length;\n        }\n    }\n    subSource(limit) {\n        return new SubSource(this, limit);\n    }\n    async subSyncSource(limit) {\n        const buf = await this.readExact(limit);\n        return new SyncArraySource(buf);\n    }\n    close() {\n        this.reader.releaseLock();\n    }\n}\nclass ArraySource {\n    _pos;\n    items;\n    constructor(items) {\n        this._pos = 0;\n        this.items = Uint8Array.from(items);\n    }\n    get pos() {\n        return this._pos;\n    }\n    readAvailable(limit) {\n        if (this.items.byteLength === 0 || this._pos == this.items.byteLength || limit === 0) {\n            return Promise.resolve(null);\n        }\n        const max = Math.min(this.items.byteLength - this._pos, limit);\n        const r = this.items.subarray(this._pos, this._pos + max);\n        this._pos += r.byteLength;\n        return Promise.resolve(r);\n    }\n    read(eof) {\n        try {\n            if (this.items.length - this._pos < 1) {\n                if (eof) {\n                    return Promise.resolve(null);\n                }\n                else {\n                    throw new Error('unexpected EOF.');\n                }\n            }\n            const r = this.items[this._pos];\n            this._pos += 1;\n            return Promise.resolve(r);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    readExact(n) {\n        try {\n            if (n === 0) {\n                return Promise.resolve(Uint8Array.from([]));\n            }\n            if (n < 1) {\n                throw new Error('illegal argument.');\n            }\n            if (this.items.length - this._pos < n) {\n                throw new Error('unexpected EOF.');\n            }\n            const r = this.items.subarray(this._pos, this._pos + n);\n            this._pos += n;\n            return Promise.resolve(r);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    skip(n) {\n        try {\n            if (n === 0) {\n                return Promise.resolve();\n            }\n            if (n < 1) {\n                throw new Error('illegal argument.');\n            }\n            if (this.items.length - this._pos < n) {\n                throw new Error('unexpected EOF.');\n            }\n            this._pos += n;\n            return Promise.resolve();\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    subSource(limit) {\n        return new SubSource(this, limit);\n    }\n    async subSyncSource(limit) {\n        const buf = await this.readExact(limit);\n        return new SyncArraySource(buf);\n    }\n    close() {\n        // nop\n    }\n}\nclass SubSource {\n    delegate;\n    rest;\n    constructor(delegate, limit) {\n        if (limit < 0) {\n            throw new Error('illegal argument.');\n        }\n        this.delegate = delegate;\n        this.rest = limit;\n    }\n    get pos() {\n        return this.delegate.pos;\n    }\n    async readAvailable(limit) {\n        const max = Math.min(limit, this.rest);\n        const data = await this.delegate.readAvailable(max);\n        if (data) {\n            this.rest -= data.byteLength;\n        }\n        return data;\n    }\n    async read(eof) {\n        this.checkLimit(1);\n        let r;\n        if (eof === true) {\n            r = await this.delegate.read(true);\n        }\n        else {\n            r = await this.delegate.read();\n        }\n        if (r) {\n            this.rest -= 1;\n        }\n        return r;\n    }\n    async readExact(n) {\n        this.checkLimit(n);\n        const r = await this.delegate.readExact(n);\n        this.rest -= r.length;\n        return r;\n    }\n    async skip(n) {\n        this.checkLimit(n);\n        await this.delegate.skip(n);\n        this.rest -= n;\n    }\n    subSource(limit) {\n        return new SubSource(this, limit);\n    }\n    async subSyncSource(limit) {\n        const buf = await this.readExact(limit);\n        return new SyncArraySource(buf);\n    }\n    checkLimit(needs) {\n        if (this.rest < needs) {\n            throw new Error('limit reached.');\n        }\n    }\n}\nclass SyncArraySource {\n    _pos;\n    items;\n    constructor(items) {\n        this._pos = 0;\n        this.items = Uint8Array.from(items);\n    }\n    get pos() {\n        return this._pos;\n    }\n    get remaining() {\n        return this.items.length - this._pos;\n    }\n    read(eof) {\n        if (this.items.length - this._pos < 1) {\n            if (eof) {\n                null;\n            }\n            else {\n                throw new Error('unexpected EOF.');\n            }\n        }\n        const r = this.items[this._pos];\n        this._pos += 1;\n        return r;\n    }\n    readExact(n) {\n        if (n === 0) {\n            return Uint8Array.from([]);\n        }\n        if (n < 1) {\n            throw new Error('illegal argument.');\n        }\n        if (this.items.length - this._pos < n) {\n            throw new Error('unexpected EOF.');\n        }\n        const r = this.items.subarray(this._pos, this._pos + n);\n        this._pos += n;\n        return r;\n    }\n    skip(n) {\n        if (n === 0) {\n            return;\n        }\n        if (n < 1) {\n            throw new Error('illegal argument.');\n        }\n        if (this.items.length - this._pos < n) {\n            throw new Error('unexpected EOF.');\n        }\n        this._pos += n;\n    }\n}\nexport function bufferToHex(data) {\n    return data.reduce((t, x) => t + ' ' + x.toString(16).padStart(2, '0'), '');\n}\n//# sourceMappingURL=streaming.js.map","export const hasWASM = () => (typeof window !== \"undefined\" &&\n    typeof window[\"WebAssembly\"] !== \"undefined\") ||\n    (typeof global !== \"undefined\" &&\n        typeof global[\"WebAssembly\"] !== \"undefined\");\n","import { defError } from \"./deferror.js\";\nexport const UnsupportedOperationError = defError(() => \"unsupported operation\");\nexport const unsupported = (msg) => {\n    throw new UnsupportedOperationError(msg);\n};\n","export const defError = (prefix, suffix = (msg) => (msg !== undefined ? \": \" + msg : \"\")) => class extends Error {\n    constructor(msg) {\n        super(prefix(msg) + suffix(msg));\n    }\n};\n","export const DEFAULT_EPS = 1e-6;\n/**\n * Internal use only. **Do NOT use in user land code!**\n *\n * @internal\n */\nexport const SEMAPHORE = Symbol();\n/**\n * No-effect placeholder function.\n */\nexport const NO_OP = () => { };\n/**\n * Catch-all event ID\n */\nexport const EVENT_ALL = \"*\";\nexport const EVENT_ENABLE = \"enable\";\nexport const EVENT_DISABLE = \"disable\";\n","export class Reduced {\n    constructor(val) {\n        this.value = val;\n    }\n    deref() {\n        return this.value;\n    }\n}\nexport const reduced = (x) => new Reduced(x);\nexport const isReduced = (x) => x instanceof Reduced;\nexport const ensureReduced = (x) => x instanceof Reduced ? x : new Reduced(x);\nexport const unreduced = (x) => (x instanceof Reduced ? x.deref() : x);\n","import { NO_OP, SEMAPHORE } from \"@thi.ng/api/api\";\nimport { isIterable } from \"@thi.ng/checks/is-iterable\";\nimport { ensureTransducer } from \"./ensure.js\";\nimport { push } from \"./push.js\";\nimport { isReduced, unreduced } from \"./reduced.js\";\n/**\n * Takes a transducer and input iterable. Returns iterator of\n * transformed results.\n *\n * @param xform -\n * @param xs -\n */\nexport function* iterator(xform, xs) {\n    const rfn = ensureTransducer(xform)(push());\n    const complete = rfn[1];\n    const reduce = rfn[2];\n    for (let x of xs) {\n        const y = reduce([], x);\n        if (isReduced(y)) {\n            yield* unreduced(complete(y.deref()));\n            return;\n        }\n        if (y.length) {\n            yield* y;\n        }\n    }\n    yield* unreduced(complete([]));\n}\n/**\n * Optimized version of {@link iterator} for transducers which are\n * guaranteed to:\n *\n * 1) Only produce none or a single result per input\n * 2) Do not require a `completion` reduction step\n *\n * @param xform -\n * @param xs -\n */\nexport function* iterator1(xform, xs) {\n    const reduce = (ensureTransducer(xform)([NO_OP, NO_OP, (_, x) => x]))[2];\n    for (let x of xs) {\n        let y = reduce(SEMAPHORE, x);\n        if (isReduced(y)) {\n            y = unreduced(y.deref());\n            if (y !== SEMAPHORE) {\n                yield y;\n            }\n            return;\n        }\n        if (y !== SEMAPHORE) {\n            yield y;\n        }\n    }\n}\n/**\n * Helper function used by various transducers to wrap themselves as\n * transforming iterators. Delegates to {@link iterator1} by default.\n *\n * @param xform -\n * @param args -\n * @param impl -\n *\n * @internal\n */\nexport const __iter = (xform, args, impl = iterator1) => {\n    const n = args.length - 1;\n    return isIterable(args[n])\n        ? args.length > 1\n            ? impl(xform.apply(null, args.slice(0, n)), args[n])\n            : impl(xform(), args[0])\n        : undefined;\n};\n","import { implementsFunction } from \"@thi.ng/checks/implements-function\";\nexport const ensureTransducer = (x) => implementsFunction(x, \"xform\") ? x.xform() : x;\n","export const implementsFunction = (x, fn) => x != null && typeof x[fn] === \"function\";\n","import { hasWASM } from \"@thi.ng/checks/has-wasm\";\nimport { unsupported } from \"@thi.ng/errors/unsupported\";\nimport { base64Decode } from \"@thi.ng/transducers-binary/base64\";\nimport { BINARY } from \"./binary.js\";\nlet wasm;\nlet U8;\nif (hasWASM()) {\n    const inst = new WebAssembly.Instance(new WebAssembly.Module(base64Decode(BINARY)));\n    wasm = inst.exports;\n    // mapped view of the data buffer\n    U8 = new Uint8Array(wasm.memory.buffer, wasm.buf, 16);\n}\nconst ensureWASM = () => !wasm && unsupported(\"WASM module unavailable\");\nconst encode = (op, signed) => (x) => {\n    ensureWASM();\n    const value = signed\n        ? BigInt.asIntN(64, BigInt(x))\n        : BigInt.asUintN(64, BigInt(x));\n    return U8.slice(0, wasm[op](value));\n};\nconst decode = (op, signed) => (src, idx = 0) => {\n    ensureWASM();\n    U8.set(src.subarray(idx, Math.min(idx + 10, src.length)), 0);\n    const value = wasm[op](0, 0);\n    return [\n        signed ? BigInt.asIntN(64, value) : BigInt.asUintN(64, value),\n        U8[0],\n    ];\n};\n/**\n * Encodes signed integer `x` into LEB128 varint format and returns\n * encoded bytes.\n *\n * @param x -\n */\nexport const encodeSLEB128 = encode(\"leb128EncodeI64\", true);\n/**\n * Takes Uint8Array with LEB128 encoded signed varint and an optional\n * start index to decode from. Returns 2-tuple of decoded value and\n * number of bytes consumed. Consumes up to 10 bytes from `src`.\n *\n * @param src -\n * @param idx -\n */\nexport const decodeSLEB128 = decode(\"leb128DecodeI64\", true);\n/**\n * Encodes unsigned integer `x` into LEB128 varint format and returns\n * encoded bytes. Values < 0 will be encoded as zero.\n *\n * @param x -\n */\nexport const encodeULEB128 = encode(\"leb128EncodeU64\", false);\n/**\n * Takes Uint8Array with LEB128 encoded unsigned varint and an optional\n * start index to decode from. Returns 2-tuple of decoded value and\n * number of bytes consumed. Consumes up to 10 bytes from `src`.\n *\n * @param src -\n * @param idx -\n */\nexport const decodeULEB128 = decode(\"leb128DecodeU64\", false);\n","import { compR } from \"@thi.ng/transducers/compr\";\nimport { iterator, iterator1, __iter } from \"@thi.ng/transducers/iterator\";\nimport { isReduced, reduced } from \"@thi.ng/transducers/reduced\";\nconst B64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst B64_SAFE = B64_CHARS.substring(0, 62) + \"-_\";\nexport function base64Decode(src) {\n    return src\n        ? new Uint8Array([...iterator1(base64Decode(), src)])\n        : (rfn) => {\n            const r = rfn[2];\n            let bc = 0, bs = 0;\n            return compR(rfn, (acc, x) => {\n                switch (x) {\n                    case \"-\":\n                        x = \"+\";\n                        break;\n                    case \"_\":\n                        x = \"/\";\n                        break;\n                    case \"=\":\n                        return reduced(acc);\n                    default:\n                }\n                const y = B64_CHARS.indexOf(x);\n                bs = bc & 3 ? (bs << 6) + y : y;\n                if (bc++ & 3) {\n                    acc = r(acc, 255 & (bs >> ((-2 * bc) & 6)));\n                }\n                return acc;\n            });\n        };\n}\nexport function base64Encode(...args) {\n    const iter = __iter(base64Encode, args, iterator);\n    if (iter) {\n        return [...iter].join(\"\");\n    }\n    return ([init, complete, reduce]) => {\n        let state = 0;\n        let b;\n        const opts = { safe: false, buffer: 1024, ...args[0] };\n        const chars = opts.safe ? B64_SAFE : B64_CHARS;\n        const buf = [];\n        return [\n            init,\n            (acc) => {\n                switch (state) {\n                    case 1:\n                        buf.push(chars[(b >> 18) & 0x3f], chars[(b >> 12) & 0x3f], \"=\", \"=\");\n                        break;\n                    case 2:\n                        buf.push(chars[(b >> 18) & 0x3f], chars[(b >> 12) & 0x3f], chars[(b >> 6) & 0x3f], \"=\");\n                        break;\n                    default:\n                }\n                while (buf.length && !isReduced(acc)) {\n                    acc = reduce(acc, buf.shift());\n                }\n                return complete(acc);\n            },\n            (acc, x) => {\n                switch (state) {\n                    case 0:\n                        state = 1;\n                        b = x << 16;\n                        break;\n                    case 1:\n                        state = 2;\n                        b += x << 8;\n                        break;\n                    default:\n                        state = 0;\n                        b += x;\n                        buf.push(chars[(b >> 18) & 0x3f], chars[(b >> 12) & 0x3f], chars[(b >> 6) & 0x3f], chars[b & 0x3f]);\n                        if (buf.length >= opts.buffer) {\n                            for (let i = 0, n = buf.length; i < n && !isReduced(acc); i++) {\n                                acc = reduce(acc, buf[i]);\n                            }\n                            buf.length = 0;\n                        }\n                }\n                return acc;\n            },\n        ];\n    };\n}\n","/**\n * Reducer composition helper, internally used by various transducers\n * during initialization. Takes existing reducer `rfn` (a 3-tuple) and a\n * reducing function `fn`. Returns a new reducer tuple.\n *\n * @remarks\n * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.\n * `fn` accepts values of type `C` and produces interim results of type\n * `B`, which are then (possibly) passed to the \"inner\" `rfn[2]`\n * function. Therefore the resulting reducer takes inputs of `C` and an\n * accumulator of type `A`.\n *\n * It is assumed that `fn` internally calls `rfn[2]` to pass its own\n * results for further processing by the nested reducer `rfn`.\n *\n * @example\n * ```ts\n * compR(rfn, fn)\n * // [rfn[0], rfn[1], fn]\n * ```\n *\n * @param rfn -\n * @param fn -\n */\nexport const compR = (rfn, fn) => [rfn[0], rfn[1], fn];\n","// thing:no-export\n/**\n * Generated @ 2022-12-02T12:00:53Z\n *\n * @internal\n */\nexport const BINARY = \"AGFzbQEAAAABCgJgAX4Bf2AAAX4DBQQAAQABBQMBABEGCQF/AEGAgMAACwdYBgZtZW1vcnkCAA9sZWIxMjhFbmNvZGVVNjQAAANidWYDAA9sZWIxMjhEZWNvZGVVNjQAAQ9sZWIxMjhFbmNvZGVJNjQAAg9sZWIxMjhEZWNvZGVJNjQAAwrBAwRbAQJ/AkAgAEKAAVoEQANAIAFBgIBAayAAp0H/AHEgAEL/AFZBB3RyOgAAIAFBAWohASAAQoABVCAAQgeIIQBFDQALDAELQYCAwAAgADwAAEEBIQELIAFB/wFxC1ECA38CfgNAAkAgAEEBaiECIABBgIBAaywAACIBQf8Aca0gA4YgBIQhBCABQQBODQAgA0IHfCEDIABBCUkgAiEADQELC0GAgMAAIAI6AAAgBAuRAQEDfwJAIABCQH1CgAFaBEBBASECA0AgAkEBcUUNAiABQYCAQGtBAEGAfyAApyICQcAAcSIDRSAAQoABVHEgA0EGdiAAQgeHIgBCf1FxciIDGyACQf8AcXI6AAAgA0UhAiABQQFqIQEMAAsAC0GAgMAAIABCOYinQcAAcSAAp0E/cXI6AABBASEBCyABQf8BcQt+AgN/A35BfyEAA0ACQCAAQQFqIQEgA0IHfCEFIABBgYDAAGotAAAiAEH/AHGtIAOGIASEIQQgAMAiAkEATg0AIAEhACAFIQMgAUEJSQ0BCwtBgIDAACABQQFqOgAAIARCfyAFhkIAIAJBwABxQQZ2G0IAIAFB/wFxQQlJG4QL\";\n","// adapted from https://github.com/yskszk63/stream-wasm-parser by yusuke suzuki under MIT License\nimport * as leb from '@thi.ng/leb128';\nconst textDecoder = new TextDecoder();\nexport async function readU32Async(source) {\n    return await readIntegerAsync(source, 0x00, 4294967295, leb.decodeULEB128);\n}\nexport function readU32(source) {\n    return readInteger(source, 0x00, 4294967295, leb.decodeULEB128);\n}\nexport async function readNameAsync(source) {\n    const length = await readU32(source);\n    const content = await source.readExact(length);\n    return textDecoder.decode(content);\n}\nexport function readStringArray(src) {\n    const count = readU32(src);\n    const arr = [];\n    for (let i = 0; i < count; i++) {\n        arr.push(readName(src));\n    }\n    return arr;\n}\nexport function readName(source) {\n    const length = readU32(source);\n    const content = source.readExact(length);\n    return textDecoder.decode(content);\n}\nexport function parseAsExternalKind(k1) {\n    switch (k1) {\n        case 0x00: return \"func\" /* ExternalKind.Func */;\n        case 0x01: return \"table\" /* ExternalKind.Table */;\n        case 0x02: return \"memory\" /* ExternalKind.Memory */;\n        case 0x03: return \"global\" /* ExternalKind.Global */;\n        case 0x04: return \"tag\" /* ExternalKind.Tag */;\n        default:\n            throw new Error(`unknown external kind. ${k1}`);\n    }\n}\nexport function readComponentExternalKind(src) {\n    const k1 = readU32(src);\n    return (k1 == 0x00)\n        ? parseAsComponentExternalKind(k1, readU32(src))\n        : parseAsComponentExternalKind(k1);\n}\nexport function parseAsComponentExternalKind(k1, k2) {\n    switch (k1) {\n        case 0x00:\n            switch (k2) {\n                case 0x11: return \"module\" /* ComponentExternalKind.Module */;\n                default:\n                    throw new Error(`unknown component external kind 2. ${k2}`);\n            }\n        case 0x01: return \"func\" /* ComponentExternalKind.Func */;\n        case 0x02: return \"value\" /* ComponentExternalKind.Value */;\n        case 0x03: return \"type\" /* ComponentExternalKind.Type */;\n        case 0x04: return \"component\" /* ComponentExternalKind.Component */;\n        case 0x05: return \"instance\" /* ComponentExternalKind.Instance */;\n        default:\n            throw new Error(`unknown component external kind. 0x${k1.toString(16)}`);\n    }\n}\nexport function readInstanceTypeDeclarations(src) {\n    const count = readU32(src);\n    const declarations = [];\n    for (let i = 0; i < count; i++) {\n        const type = src.read();\n        let declaration;\n        switch (type) {\n            case 0x00: {\n                declaration = {\n                    tag: \"InstanceTypeDeclarationCoreType\" /* ModelTag.InstanceTypeDeclarationCoreType */,\n                    value: undefined,\n                };\n                break;\n            }\n            case 0x01: {\n                declaration = {\n                    tag: \"InstanceTypeDeclarationType\" /* ModelTag.InstanceTypeDeclarationType */,\n                    value: readComponentType(src),\n                };\n                break;\n            }\n            case 0x02: {\n                declaration = {\n                    tag: \"InstanceTypeDeclarationAlias\" /* ModelTag.InstanceTypeDeclarationAlias */,\n                    value: undefined,\n                };\n                break;\n            }\n            case 0x04: {\n                declaration = {\n                    tag: \"InstanceTypeDeclarationExport\" /* ModelTag.InstanceTypeDeclarationExport */,\n                    name: readComponentExternName(src),\n                    ty: readComponentTypeRef(src)\n                };\n                break;\n            }\n        }\n        declarations.push(declaration);\n    }\n    return declarations;\n}\nexport function readComponentExternName(src) {\n    const type = readU32(src);\n    switch (type) {\n        case 0x00: return {\n            tag: \"ComponentExternNameKebab\" /* ModelTag.ComponentExternNameKebab */,\n            name: readName(src),\n        };\n        case 0x01: return {\n            tag: \"ComponentExternNameInterface\" /* ModelTag.ComponentExternNameInterface */,\n            name: readName(src),\n        };\n        default:\n            throw new Error(`unknown ComponentExternName. ${type}`);\n    }\n}\nexport function readDestructor(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x00: return undefined;\n        case 0x01: return readU32(src);\n        default: throw new Error('Invalid leading byte in resource destructor');\n    }\n}\nexport function readComponentTypeDefined(src, type) {\n    switch (type) {\n        case 0x68: {\n            return {\n                tag: \"ComponentTypeDefinedBorrow\" /* ModelTag.ComponentTypeDefinedBorrow */,\n                value: readU32(src),\n            };\n        }\n        case 0x69: {\n            return {\n                tag: \"ComponentTypeDefinedOwn\" /* ModelTag.ComponentTypeDefinedOwn */,\n                value: readU32(src),\n            };\n        }\n        case 0x6a: {\n            return {\n                tag: \"ComponentTypeDefinedResult\" /* ModelTag.ComponentTypeDefinedResult */,\n                ok: readComponentValType(src),\n                err: readComponentValType(src),\n            };\n        }\n        case 0x6b: {\n            return {\n                tag: \"ComponentTypeDefinedOption\" /* ModelTag.ComponentTypeDefinedOption */,\n                value: readComponentValType(src),\n            };\n        }\n        case 0x6d: {\n            return {\n                tag: \"ComponentTypeDefinedEnum\" /* ModelTag.ComponentTypeDefinedEnum */,\n                members: readStringArray(src),\n            };\n        }\n        case 0x6e: {\n            return {\n                tag: \"ComponentTypeDefinedFlags\" /* ModelTag.ComponentTypeDefinedFlags */,\n                members: readStringArray(src),\n            };\n        }\n        case 0x6f: {\n            const count = readU32(src);\n            const members = [];\n            for (let i = 0; i < count; i++) {\n                members.push(readComponentValType(src));\n            }\n            return {\n                tag: \"ComponentTypeDefinedTuple\" /* ModelTag.ComponentTypeDefinedTuple */,\n                members: members,\n            };\n        }\n        case 0x70: {\n            return {\n                tag: \"ComponentTypeDefinedList\" /* ModelTag.ComponentTypeDefinedList */,\n                value: readComponentValType(src),\n            };\n        }\n        case 0x71: {\n            const count = readU32(src);\n            const variants = [];\n            for (let i = 0; i < count; i++) {\n                variants.push({\n                    name: readName(src),\n                    ty: readComponentValType(src),\n                    refines: readU32(src),\n                });\n            }\n            return {\n                tag: \"ComponentTypeDefinedVariant\" /* ModelTag.ComponentTypeDefinedVariant */,\n                variants: variants,\n            };\n        }\n        case 0x72: {\n            const count = readU32(src);\n            const members = [];\n            for (let i = 0; i < count; i++) {\n                members.push({\n                    name: readName(src),\n                    type: readComponentValType(src),\n                });\n            }\n            return {\n                tag: \"ComponentTypeDefinedRecord\" /* ModelTag.ComponentTypeDefinedRecord */,\n                members: members,\n            };\n        }\n        default: throw new Error(`Unrecognized type in readComponentTypeDefined: ${type}`);\n    }\n}\nexport function readComponentInstantiationArgs(src) {\n    const count = readU32(src);\n    const args = [];\n    for (let i = 0; i < count; i++) {\n        args.push({\n            name: readName(src),\n            kind: readComponentExternalKind(src),\n            index: readU32(src)\n        });\n    }\n    return args;\n}\nexport function readCoreInstance(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x00: {\n            const index = readU32(src);\n            return {\n                tag: \"CoreInstanceInstantiate\" /* ModelTag.CoreInstanceInstantiate */,\n                module_index: index,\n                args: readInstantiationArgs(src),\n            };\n        }\n        case 0x01: {\n            return {\n                tag: \"CoreInstanceFromExports\" /* ModelTag.CoreInstanceFromExports */,\n                exports: readExports(src),\n            };\n        }\n        default: throw new Error(`Unrecognized type in readCoreInstance: ${type}`);\n    }\n}\nexport function readExports(src) {\n    const count = readU32(src);\n    const exports = [];\n    for (let i = 0; i < count; i++) {\n        const name = readName(src);\n        const kind = readU32(src);\n        const index = readU32(src);\n        exports.push({\n            name: name,\n            kind: parseAsExternalKind(kind),\n            index: index,\n        });\n    }\n    return exports;\n}\nexport function readInstantiationArgs(src) {\n    const count = readU32(src);\n    const args = [];\n    for (let i = 0; i < count; i++) {\n        const name = readName(src);\n        const kind = readInstantiationArgKind(src);\n        const index = readU32(src);\n        args.push({\n            name: name,\n            kind: kind,\n            index: index\n        });\n    }\n    return args;\n}\nexport function readInstantiationArgKind(src) {\n    const kind = src.read();\n    if (kind != 0x12)\n        throw new Error(`Unrecognized kind in readInstantiationArgKind: ${kind}`);\n    return \"instance\" /* InstantiationArgKind.Instance */;\n}\nexport function readCanonicalFunction(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x00: {\n            const controlByte = src.read();\n            if (controlByte != 0x00)\n                throw new Error(`Unrecognized byte for CanonicalFunctionLift in readCanonicalFunction: ${controlByte}`);\n            return {\n                tag: \"CanonicalFunctionLift\" /* ModelTag.CanonicalFunctionLift */,\n                core_func_index: readU32(src),\n                options: readCanonicalOptions(src),\n                type_index: readU32(src),\n            };\n        }\n        case 0x01: {\n            const controlByte = src.read();\n            if (controlByte != 0x00)\n                throw new Error(`Unrecognized byte for CanonicalFunctionLower in readCanonicalFunction: ${controlByte}`);\n            return {\n                tag: \"CanonicalFunctionLower\" /* ModelTag.CanonicalFunctionLower */,\n                func_index: readU32(src),\n                options: readCanonicalOptions(src),\n            };\n        }\n        case 0x02: return {\n            tag: \"CanonicalFunctionResourceNew\" /* ModelTag.CanonicalFunctionResourceNew */,\n            resource: readU32(src),\n        };\n        case 0x03: return {\n            tag: \"CanonicalFunctionResourceDrop\" /* ModelTag.CanonicalFunctionResourceDrop */,\n            resource: readU32(src),\n        };\n        case 0x04: return {\n            tag: \"CanonicalFunctionResourceRep\" /* ModelTag.CanonicalFunctionResourceRep */,\n            resource: readU32(src),\n        };\n        default: throw new Error(`Unrecognized type in readCanonicalFunction: ${type}`);\n    }\n}\nexport function readCanonicalOptions(src) {\n    const optionsCount = readU32(src);\n    const options = [];\n    for (let i = 0; i < optionsCount; i++) {\n        options.push(readCanonicalOption(src));\n    }\n    return options;\n}\nexport function readCanonicalOption(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x00: return {\n            tag: \"CanonicalOptionUTF8\" /* ModelTag.CanonicalOptionUTF8 */,\n        };\n        case 0x01: return {\n            tag: \"CanonicalOptionUTF16\" /* ModelTag.CanonicalOptionUTF16 */,\n        };\n        case 0x02: return {\n            tag: \"CanonicalOptionCompactUTF16\" /* ModelTag.CanonicalOptionCompactUTF16 */,\n        };\n        case 0x03: return {\n            tag: \"CanonicalOptionMemory\" /* ModelTag.CanonicalOptionMemory */,\n            value: readU32(src),\n        };\n        case 0x04: return {\n            tag: \"CanonicalOptionRealloc\" /* ModelTag.CanonicalOptionRealloc */,\n            value: readU32(src),\n        };\n        case 0x05: return {\n            tag: \"CanonicalOptionPostReturn\" /* ModelTag.CanonicalOptionPostReturn */,\n            value: readU32(src),\n        };\n        default: throw new Error(`Unrecognized type in readCanonicalOption = ${type}.`);\n    }\n}\nexport function readComponentType(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x3F: {\n            return {\n                tag: \"ComponentTypeResource\" /* ModelTag.ComponentTypeResource */,\n                rep: readU32(src),\n                dtor: readDestructor(src)\n            };\n        }\n        case 0x40: {\n            return {\n                tag: \"ComponentTypeFunc\" /* ModelTag.ComponentTypeFunc */,\n                params: readNamedValues(src),\n                results: readComponentFuncResult(src),\n            };\n        }\n        case 0x41: {\n            return {\n                tag: \"ComponentTypeComponent\" /* ModelTag.ComponentTypeComponent */,\n                declarations: undefined,\n            };\n        }\n        case 0x42: {\n            return {\n                tag: \"ComponentTypeInstance\" /* ModelTag.ComponentTypeInstance */,\n                declarations: readInstanceTypeDeclarations(src),\n            };\n        }\n        default: {\n            return readComponentTypeDefined(src, type);\n        }\n    }\n}\nexport function readComponentTypeRef(src) {\n    const type = readU32(src);\n    switch (type) {\n        case 0x00: return {\n            tag: \"ComponentTypeRefModule\" /* ModelTag.ComponentTypeRefModule */,\n            value: readU32(src),\n        };\n        case 0x01: return {\n            tag: \"ComponentTypeRefFunc\" /* ModelTag.ComponentTypeRefFunc */,\n            value: readU32(src),\n        };\n        case 0x02: return {\n            tag: \"ComponentTypeRefValue\" /* ModelTag.ComponentTypeRefValue */,\n            value: readComponentValType(src),\n        };\n        case 0x03: return {\n            tag: \"ComponentTypeRefType\" /* ModelTag.ComponentTypeRefType */,\n            value: readTypeBounds(src),\n        };\n        case 0x04: return {\n            tag: \"ComponentTypeRefInstance\" /* ModelTag.ComponentTypeRefInstance */,\n            value: readU32(src),\n        };\n        case 0x05: return {\n            tag: \"ComponentTypeRefComponent\" /* ModelTag.ComponentTypeRefComponent */,\n            value: readU32(src),\n        };\n        default:\n            throw new Error(`unknown ComponentExternName. ${type}`);\n    }\n}\nexport function readNamedValues(src) {\n    const values = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        values.push({\n            name: readName(src),\n            type: readComponentValType(src),\n        });\n    }\n    return values;\n}\nexport function readComponentFuncResult(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x00:\n            return {\n                tag: \"ComponentFuncResultUnnamed\" /* ModelTag.ComponentFuncResultUnnamed */,\n                type: readComponentValType(src),\n            };\n        case 0x01:\n            return {\n                tag: \"ComponentFuncResultNamed\" /* ModelTag.ComponentFuncResultNamed */,\n                values: readNamedValues(src),\n            };\n        default: throw new Error(`unknown ComponentFuncResult type: ${type}`);\n    }\n}\nexport function readComponentValType(src) {\n    const b = readU32(src);\n    if (0x73 <= b && b <= 0x7f) {\n        return {\n            tag: \"ComponentValTypePrimitive\" /* ModelTag.ComponentValTypePrimitive */,\n            value: parsePrimitiveValType(b),\n        };\n    }\n    return {\n        tag: \"ComponentValTypeType\" /* ModelTag.ComponentValTypeType */,\n        value: b,\n    };\n}\nexport function readTypeBounds(src) {\n    const b = readU32(src);\n    switch (b) {\n        case 0x00: return {\n            tag: \"TypeBoundsEq\" /* ModelTag.TypeBoundsEq */,\n            value: readU32(src),\n        };\n        case 0x01: return {\n            tag: \"TypeBoundsSubResource\" /* ModelTag.TypeBoundsSubResource */,\n        };\n        default:\n            throw new Error(`unknown type bounds. ${b}`);\n    }\n}\nexport function parsePrimitiveValType(b) {\n    switch (b) {\n        case 0x7f: return \"bool\" /* PrimitiveValType.Bool */;\n        case 0x7e: return \"s8\" /* PrimitiveValType.S8 */;\n        case 0x7d: return \"u8\" /* PrimitiveValType.U8 */;\n        case 0x7c: return \"s16\" /* PrimitiveValType.S16 */;\n        case 0x7b: return \"u16\" /* PrimitiveValType.U16 */;\n        case 0x7a: return \"s32\" /* PrimitiveValType.S32 */;\n        case 0x79: return \"u32\" /* PrimitiveValType.U32 */;\n        case 0x78: return \"s64\" /* PrimitiveValType.S64 */;\n        case 0x77: return \"u64\" /* PrimitiveValType.U64 */;\n        case 0x76: return \"f32\" /* PrimitiveValType.Float32 */;\n        case 0x75: return \"f64\" /* PrimitiveValType.Float64 */;\n        case 0x74: return \"char\" /* PrimitiveValType.Char */;\n        case 0x73: return \"string\" /* PrimitiveValType.String */;\n        default: throw new Error(`unknown primitive val type. ${b}`);\n    }\n}\nexport function parseAsComponentOuterAliasKind(k1, k2) {\n    switch (k1) {\n        case 0x00:\n            switch (k2) {\n                case 0x10: return \"coretype\" /* ComponentOuterAliasKind.CoreType */;\n                case 0x11: return \"coremodule\" /* ComponentOuterAliasKind.CoreModule */;\n                default:\n                    throw new Error(`unknown outer alias kind 2. ${k2}`);\n            }\n        case 0x03: return \"type\" /* ComponentOuterAliasKind.Type */;\n        case 0x04: return \"component\" /* ComponentOuterAliasKind.Component */;\n        default:\n            throw new Error(`unknown outer alias kind. ${k1}`);\n    }\n}\nasync function readIntegerAsync(source, min, max, decoder) {\n    const src = await readRawIntegerAsync(source);\n    const [r, consumed] = decoder(src);\n    if (consumed !== src.length) {\n        throw new Error(`invalid data. ${consumed} !== ${src.length}`);\n    }\n    if (r < min || r > max) {\n        throw new Error(`overflow. ${bits}, ${r}`);\n    }\n    return Number(r);\n}\nfunction readInteger(source, min, max, decoder) {\n    const src = readRawInteger(source);\n    const [r, consumed] = decoder(src);\n    if (consumed !== src.length) {\n        throw new Error(`invalid data. ${consumed} !== ${src.length}`);\n    }\n    if (r < min || r > max) {\n        throw new Error(`overflow. ${bits}, ${r}`);\n    }\n    return Number(r);\n}\nconst bits = 32;\nconst maxLen = Math.ceil(bits / 7) | 0;\nasync function readRawIntegerAsync(source) {\n    const buf = [];\n    for (let i = 0; i < maxLen; i++) {\n        const b = await source.read();\n        buf.push(b);\n        if ((b & 0x80) === 0) {\n            break;\n        }\n    }\n    return Uint8Array.from(buf);\n}\nfunction readRawInteger(source) {\n    const buf = [];\n    for (let i = 0; i < maxLen; i++) {\n        const b = source.read();\n        buf.push(b);\n        if ((b & 0x80) === 0) {\n            break;\n        }\n    }\n    return Uint8Array.from(buf);\n}\n//# sourceMappingURL=values.js.map","import { readU32, readComponentExternalKind, readComponentExternName, readComponentTypeRef } from './values';\n// see also https://github.com/bytecodealliance/wasm-tools/blob/e2af293273db65712b6f31da85f7aa5eb31abfde/crates/wasmparser/src/readers/component/exports.rs#L86\n// https://github.com/WebAssembly/component-model/blob/main/design/mvp/Binary.md#import-and-export-definitions\nexport function parseSectionExport(ctx, src) {\n    const sections = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const section = {\n            tag: \"ComponentExport\" /* ModelTag.ComponentExport */,\n            name: readComponentExternName(src),\n            kind: readComponentExternalKind(src),\n            index: readU32(src),\n            ty: readU32(src) === 0 ? undefined : readComponentTypeRef(src)\n        };\n        sections.push(section);\n    }\n    return sections;\n}\n//# sourceMappingURL=export.js.map","import { readU32, parseAsExternalKind, parseAsComponentExternalKind, parseAsComponentOuterAliasKind, readName } from './values';\n// see also https://github.com/bytecodealliance/wasm-tools/blob/e2af293273db65712b6f31da85f7aa5eb31abfde/crates/wasmparser/src/readers/component/exports.rs#L86\n// https://github.com/WebAssembly/component-model/blob/main/design/mvp/Binary.md#alias-definitions\nexport function parseSectionAlias(ctx, src) {\n    const count = readU32(src);\n    const aliases = [];\n    for (let i = 0; i < count; i++) {\n        // We don't know what type of alias it is yet, so just read the sort bytes\n        const b1 = readU32(src);\n        const b2 = (b1 === 0) ? readU32(src) : undefined;\n        const alias = parseAliasTarget(src, b1, b2);\n        aliases.push(alias);\n    }\n    return aliases;\n}\nfunction parseAliasTarget(src, b1, b2) {\n    const k1 = readU32(src);\n    switch (k1) {\n        case 0x00:\n            return {\n                tag: \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */,\n                kind: parseAsComponentExternalKind(b1, b2),\n                instance_index: readU32(src),\n                name: readName(src)\n            };\n        case 0x01:\n            return {\n                tag: \"ComponentAliasCoreInstanceExport\" /* ModelTag.ComponentAliasCoreInstanceExport */,\n                kind: parseAsExternalKind(b2),\n                instance_index: readU32(src),\n                name: readName(src)\n            };\n        case 0x02:\n            return {\n                tag: \"ComponentAliasOuter\" /* ModelTag.ComponentAliasOuter */,\n                kind: parseAsComponentOuterAliasKind(b1, b2),\n                count: readU32(src),\n                index: readU32(src)\n            };\n        default:\n            throw new Error(`unknown target type. ${k1}`);\n    }\n}\n//# sourceMappingURL=alias.js.map","import { fetchLike, getBodyIfResponse } from '../utils/fetch-like';\nimport { bufferToHex, newSource } from '../utils/streaming';\nimport { parseSectionCustom, skipSection } from './otherSection';\nimport { parseSectionExport } from './export';\nimport { parseModule } from './module';\nimport { readU32Async } from './values';\nimport { parseSectionAlias } from './alias';\nimport { parseSectionImport } from './import';\nimport { parseSectionType } from './type';\nimport { parseSectionCanon } from './canon';\nimport { parseSectionCoreInstance } from './coreInstance';\nimport { parseSectionInstance } from './instance';\nexport const WIT_MAGIC = [0x00, 0x61, 0x73, 0x6d];\nexport const WIT_VERSION = [0x0D, 0x00];\nexport const WIT_LAYER = [0x01, 0x00];\nexport async function parse(componentOrUrl, options) {\n    let input = componentOrUrl;\n    if (typeof componentOrUrl === 'string') {\n        input = fetchLike(componentOrUrl);\n    }\n    input = await getBodyIfResponse(input);\n    const src = newSource(input);\n    const sections = await parseWIT(src, options);\n    return sections;\n}\nasync function parseWIT(src, options) {\n    try {\n        await checkPreamble(src);\n        const ctx = {\n            otherSectionData: options?.otherSectionData ?? false,\n            compileStreaming: options?.compileStreaming ?? WebAssembly.compileStreaming,\n            processCustomSection: options?.processCustomSection ?? undefined,\n        };\n        const model = [];\n        for (;;) {\n            const sections = await parseSection(ctx, src);\n            if (sections === null) {\n                break;\n            }\n            for (const s of sections) {\n                model.push(s);\n            }\n        }\n        return model;\n    }\n    finally {\n        src.close();\n    }\n}\nasync function checkPreamble(src) {\n    const magic = await src.readExact(WIT_MAGIC.length);\n    const version = await src.readExact(WIT_VERSION.length);\n    const layer = await src.readExact(WIT_LAYER.length);\n    const ok = magic.every((v, i) => v === WIT_MAGIC[i])\n        && version.every((v, i) => v === WIT_VERSION[i])\n        && layer.every((v, i) => v === WIT_LAYER[i]);\n    if (!ok) {\n        throw new Error('unexpected magic, version or layer.');\n    }\n}\nasync function parseSection(ctx, src) {\n    const type = await src.read(true); // byte will be enough for type\n    if (type === null) {\n        return null;\n    }\n    const size = await readU32Async(src);\n    const start = src.pos;\n    const asyncSub = type == 1 || type == 4 ? src.subSource(size) : undefined; // if this is module, we need to stream it\n    const sub = type != 1 && type != 4 ? await src.subSyncSource(size) : undefined; // otherwise it's not worth all the async overhead\n    const sections = await (() => {\n        switch (type) {\n            ///\n            /// https://github.com/WebAssembly/component-model/blob/main/design/mvp/Binary.md#component-definitions\n            ///\n            case 0: return parseSectionCustom(ctx, sub, size);\n            case 1: return parseModule(ctx, asyncSub, size);\n            case 2: return parseSectionCoreInstance(ctx, sub);\n            case 4: return parseSectionComponent(ctx, asyncSub, size);\n            case 5: return parseSectionInstance(ctx, sub);\n            case 6: return parseSectionAlias(ctx, sub);\n            case 7: return parseSectionType(ctx, sub);\n            case 8: return parseSectionCanon(ctx, sub);\n            case 10: return parseSectionImport(ctx, sub);\n            case 11: return parseSectionExport(ctx, sub);\n            //TODO: to implement\n            case 3: // core type - we don't have it in the sample\n            case 9: // start\n                return skipSection(ctx, sub, type, size); // this is all TODO\n            default:\n                throw new Error(`unknown section: ${type}`);\n        }\n    })();\n    if (sub && sub.remaining !== 0) {\n        const absoluteActual = start + sub.pos;\n        const absoluteExpected = start + size;\n        const remaining = sub.remaining;\n        const data = sub.readExact(remaining);\n        const hex = bufferToHex(data);\n        throw new Error(`invalid size after reading section ${type}: \\n`\n            + `actual position: 0x${absoluteActual.toString(16)} vs. expected position 0x${absoluteExpected.toString(16)}, remaining ${remaining}\\n`\n            + `section: ${JSON.stringify(sections)}\\n`\n            + 'remaining: ' + hex);\n    }\n    return sections;\n}\nasync function parseSectionComponent(ctx, src, size) {\n    const end = src.pos + size;\n    await checkPreamble(src);\n    let model = [];\n    for (;;) {\n        if (src.pos == end) {\n            break;\n        }\n        const sections = await parseSection(ctx, src);\n        if (sections === null) {\n            break;\n        }\n        model = [...model, ...sections];\n    }\n    return [{\n            tag: \"ComponentSection\" /* ModelTag.ComponentSection */,\n            sections: model,\n        }];\n}\n//# sourceMappingURL=index.js.map","import { readName } from './values';\nexport function parseSectionCustom(ctx, src, size) {\n    const start = src.pos;\n    const name = readName(src);\n    const nameSize = src.pos - start;\n    const data = src.readExact(size - nameSize);\n    let section = {\n        tag: \"CustomSection\" /* ModelTag.CustomSection */,\n        name,\n        data: ctx.otherSectionData ? data : undefined,\n    };\n    if (ctx.processCustomSection) {\n        section = ctx.processCustomSection(section);\n    }\n    return [section];\n}\nexport function skipSection(ctx, src, type, size) {\n    const data = src.readExact(size);\n    const section = {\n        tag: \"SkippedSection\" /* ModelTag.SkippedSection */,\n        type,\n        data: ctx.otherSectionData ? data : undefined,\n    };\n    return [section];\n}\n//# sourceMappingURL=otherSection.js.map","export async function parseModule(ctx, src, size) {\n    const res = {\n        tag: \"CoreModule\" /* ModelTag.CoreModule */,\n    };\n    if (ctx.compileStreaming) {\n        const whileReading = new Promise((resolve) => {\n            const response = toWasmResponse(src, size, resolve);\n            const module = ctx.compileStreaming(response);\n            res.module = module;\n        });\n        await whileReading;\n    }\n    else {\n        const data = await src.readExact(size);\n        res.data = data;\n    }\n    return [res];\n}\nfunction toWasmResponse(src, size, resolveWhenDoneReading) {\n    let remaining = size;\n    const pull = async (controller) => {\n        const data = await src.readAvailable(remaining);\n        if (data === null) {\n            resolveWhenDoneReading(undefined);\n            controller.close();\n        }\n        else {\n            // copy, otherwise WebAssembly.compileStreaming will detach the underlying buffer.\n            const copy = data.slice();\n            controller.enqueue(copy);\n            remaining -= data.length;\n            if (remaining === 0) {\n                resolveWhenDoneReading(undefined);\n                controller.close();\n            }\n        }\n    };\n    const rs = new ReadableStream({\n        type: 'bytes', pull,\n    });\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/wasm');\n    headers.append('Content-Length', '' + size);\n    const response = new Response(rs, {\n        headers,\n        status: 200,\n        statusText: 'OK',\n    });\n    return response;\n}\n//# sourceMappingURL=module.js.map","import { readU32, readCoreInstance } from './values';\nexport function parseSectionCoreInstance(ctx, src) {\n    const coreInstances = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const coreInstance = readCoreInstance(src);\n        coreInstances.push(coreInstance);\n    }\n    return coreInstances;\n}\n//# sourceMappingURL=coreInstance.js.map","import { readU32, readComponentInstantiationArgs } from './values';\nimport { parseSectionExport } from './export';\nexport function parseSectionInstance(ctx, src) {\n    const sections = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const section = (() => {\n            const type = readU32(src);\n            switch (type) {\n                case 0x00: {\n                    return {\n                        tag: \"ComponentInstanceInstantiate\" /* ModelTag.ComponentInstanceInstantiate */,\n                        component_index: readU32(src),\n                        args: readComponentInstantiationArgs(src),\n                    };\n                }\n                case 0x01: {\n                    return {\n                        tag: \"ComponentInstanceFromExports\" /* ModelTag.ComponentInstanceFromExports */,\n                        exports: parseSectionExport(ctx, src)\n                    };\n                }\n                default: throw new Error(`Unrecognized type in parseSectionInstance: ${type}`);\n            }\n        })();\n        sections.push(section);\n    }\n    return sections;\n}\n//# sourceMappingURL=instance.js.map","import { readU32, readComponentType } from './values';\nexport function parseSectionType(ctx, src) {\n    const sections = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const section = readComponentType(src);\n        sections.push(section);\n    }\n    return sections;\n}\n//# sourceMappingURL=type.js.map","import { readU32, readCanonicalFunction } from './values';\nexport function parseSectionCanon(ctx, src) {\n    const canonFunctions = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const canonicalFun = readCanonicalFunction(src);\n        canonFunctions.push(canonicalFun);\n    }\n    return canonFunctions;\n}\n//# sourceMappingURL=canon.js.map","import { readU32, readComponentExternName, readComponentTypeRef } from './values';\nexport function parseSectionImport(ctx, src) {\n    const sections = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const section = {\n            tag: \"ComponentImport\" /* ModelTag.ComponentImport */,\n            name: readComponentExternName(src),\n            ty: readComponentTypeRef(src)\n        };\n        sections.push(section);\n    }\n    return sections;\n}\n//# sourceMappingURL=import.js.map","const memoizeCache = new Map();\nexport function memoize(key, factory) {\n    let res = memoizeCache.get(key);\n    if (res !== undefined) {\n        return res;\n    }\n    res = factory();\n    memoizeCache.set(key, res);\n    return res;\n}\n//# sourceMappingURL=cache.js.map","import { memoize } from './cache';\nimport { createLifting } from './to-abi';\nexport function createFunctionLowering(rctx, exportModel) {\n    return memoize(exportModel, () => {\n        return (ctx, jsFunction) => {\n            const paramLowerers = [];\n            for (const param of exportModel.params) {\n                const lowerer = createLowering(rctx, param.type);\n                paramLowerers.push(lowerer);\n            }\n            const resultLifters = [];\n            switch (exportModel.results.tag) {\n                case \"ComponentFuncResultNamed\" /* ModelTag.ComponentFuncResultNamed */: {\n                    for (const res of exportModel.results.values) {\n                        const lifter = createLifting(rctx, res.type);\n                        resultLifters.push(lifter);\n                    }\n                    break;\n                }\n                case \"ComponentFuncResultUnnamed\" /* ModelTag.ComponentFuncResultUnnamed */: {\n                    const lifter = createLifting(rctx, exportModel.results.type);\n                    resultLifters.push(lifter);\n                }\n            }\n            function loweringTrampoline(...args) {\n                let covertedArgs = [];\n                // TODO do not always read spilled stack\n                for (let i = 0; i < paramLowerers.length;) {\n                    const lowerer = paramLowerers[i];\n                    const spill = lowerer.spill;\n                    const values = args.slice(i, i + spill);\n                    const converted = lowerer(ctx, ...values);\n                    i += spill;\n                    covertedArgs = [...covertedArgs, converted];\n                }\n                const resJs = jsFunction(...covertedArgs);\n                if (resultLifters.length === 1) {\n                    resultLifters[0](resJs);\n                }\n            }\n            return loweringTrampoline;\n        };\n    });\n}\nexport function createLowering(rctx, typeModel) {\n    return memoize(typeModel, () => {\n        switch (typeModel.tag) {\n            case \"ComponentValTypePrimitive\" /* ModelTag.ComponentValTypePrimitive */:\n                switch (typeModel.value) {\n                    case \"string\" /* PrimitiveValType.String */:\n                        return createStringLowering(rctx);\n                    default:\n                        throw new Error('Not implemented');\n                }\n            default:\n                throw new Error('Not implemented');\n        }\n    });\n}\nfunction createStringLowering(rctx) {\n    const fn = (ctx, ...args) => {\n        const pointer = args[0];\n        const len = args[1];\n        const view = ctx.getView(pointer, len);\n        const res = ctx.utf8Decoder.decode(view);\n        return res;\n    };\n    fn.spill = 2;\n    return fn;\n}\n//# sourceMappingURL=to-js.js.map","import { jsco_assert } from '../../utils/assert';\nimport { memoize } from './cache';\nimport { createLowering } from './to-js';\nexport function createFunctionLifting(rctx, importModel) {\n    return memoize(importModel, () => {\n        const paramLifters = [];\n        for (const param of importModel.params) {\n            const lifter = createLifting(rctx, param.type);\n            paramLifters.push(lifter);\n        }\n        const resultLowerers = [];\n        switch (importModel.results.tag) {\n            case \"ComponentFuncResultNamed\" /* ModelTag.ComponentFuncResultNamed */: {\n                for (const res of importModel.results.values) {\n                    const lowerer = createLowering(rctx, res.type);\n                    resultLowerers.push(lowerer);\n                }\n                break;\n            }\n            case \"ComponentFuncResultUnnamed\" /* ModelTag.ComponentFuncResultUnnamed */: {\n                const lowerer = createLowering(rctx, importModel.results.type);\n                resultLowerers.push(lowerer);\n            }\n        }\n        return (ctx, wasmFunction) => {\n            function liftingTrampoline(...args) {\n                let covertedArgs = [];\n                for (let i = 0; i < paramLifters.length; i++) {\n                    const lifter = paramLifters[i];\n                    const value = args[i];\n                    const converted = lifter(ctx, value);\n                    // TODO do not always spill into stack\n                    covertedArgs = [...covertedArgs, ...converted];\n                }\n                const resJs = wasmFunction(...covertedArgs);\n                if (resultLowerers.length === 1) {\n                    resultLowerers[0](resJs);\n                }\n            }\n            return liftingTrampoline;\n        };\n    });\n}\nexport function createLifting(rctx, typeModel) {\n    return memoize(typeModel, () => {\n        switch (typeModel.tag) {\n            case \"ComponentValTypePrimitive\" /* ModelTag.ComponentValTypePrimitive */:\n                switch (typeModel.value) {\n                    case \"string\" /* PrimitiveValType.String */:\n                        return createStringLifting();\n                    case \"u32\" /* PrimitiveValType.U32 */:\n                        return createU32Lifting();\n                    case \"s64\" /* PrimitiveValType.S64 */:\n                        return rctx.usesNumberForInt64\n                            ? createS64LiftingNumber()\n                            : createS64LiftingBigInt();\n                    default:\n                        throw new Error('Not implemented');\n                }\n            case \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */: {\n                const resolved = rctx.indexes.componentInstances[typeModel.instance_index];\n                return createLifting(rctx, resolved);\n            }\n            case \"ComponentTypeInstance\" /* ModelTag.ComponentTypeInstance */: {\n                const resolved = typeModel.declarations[0];\n                return createLifting(rctx, resolved);\n            }\n            case \"InstanceTypeDeclarationType\" /* ModelTag.InstanceTypeDeclarationType */: {\n                const resolved = typeModel.value;\n                jsco_assert(resolved.tag === \"ComponentTypeDefinedRecord\" /* ModelTag.ComponentTypeDefinedRecord */, () => `expected ComponentTypeDefinedRecord, got ${resolved.tag}`);\n                return createRecordLifting(rctx, resolved);\n            }\n            case \"ComponentValTypeType\" /* ModelTag.ComponentValTypeType */: {\n                const resolved = rctx.indexes.componentTypes[typeModel.value];\n                return createLifting(rctx, resolved);\n            }\n            default:\n                //return createRecordLifting(rctx, typeModel.value);\n                throw new Error('Not implemented ' + typeModel.tag);\n        }\n    });\n}\nfunction createRecordLifting(rctx, recordModel) {\n    const lifters = [];\n    for (const member of recordModel.members) {\n        const lifter = createLifting(rctx, member.type);\n        lifters.push({ name: member.name, lifter });\n    }\n    return (ctx, srcJsRecord) => {\n        // this is spilling into stack\n        // TODO allocate on heap\n        let args = [];\n        for (const { name, lifter } of lifters) {\n            const jsValue = srcJsRecord[name];\n            const wasmValue = lifter(ctx, jsValue);\n            args = [...args, ...wasmValue];\n        }\n        return args;\n    };\n}\nfunction createU32Lifting() {\n    return (_, srcJsValue) => {\n        const num = srcJsValue;\n        return [num >>> 0];\n    };\n}\nfunction createS64LiftingNumber() {\n    return (ctx, srcJsValue) => {\n        const num = srcJsValue;\n        return [Number(BigInt.asIntN(52, num))];\n    };\n}\nfunction createS64LiftingBigInt() {\n    return (ctx, srcJsValue) => {\n        const num = srcJsValue;\n        return [BigInt.asIntN(52, num)];\n    };\n}\nfunction createStringLifting() {\n    return (ctx, srcJsValue) => {\n        let str = srcJsValue;\n        if (typeof str !== 'string')\n            throw new TypeError('expected a string');\n        if (str.length === 0) {\n            return [0, 0];\n        }\n        let allocLen = 0;\n        let ptr = 0;\n        let writtenTotal = 0;\n        while (str.length > 0) {\n            ptr = ctx.realloc(ptr, allocLen, 1, allocLen + str.length);\n            allocLen += str.length;\n            const { read, written } = ctx.utf8Encoder.encodeInto(str, ctx.getViewU8(ptr + writtenTotal, allocLen - writtenTotal));\n            writtenTotal += written;\n            str = str.slice(read);\n        }\n        if (allocLen > writtenTotal)\n            ptr = ctx.realloc(ptr, allocLen, 1, writtenTotal);\n        return [ptr, writtenTotal];\n    };\n}\n//# sourceMappingURL=to-abi.js.map","var stringCamelCase = camelCase;\n\n// any combination of spaces and punctuation characters\n// thanks to http://stackoverflow.com/a/25575009\nvar wordSeparatorsRegEx = /[\\s\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,\\-.\\/:;<=>?@\\[\\]^_`{|}~]+/;\n\nvar basicCamelRegEx = /^[a-z\\u00E0-\\u00FCA-Z\\u00C0-\\u00DC][\\d|a-z\\u00E0-\\u00FCA-Z\\u00C0-\\u00DC]*$/;\nvar fourOrMoreConsecutiveCapsRegEx = /([A-Z\\u00C0-\\u00DC]{4,})/g;\nvar allCapsRegEx = /^[A-Z\\u00C0-\\u00DC]+$/;\n\nfunction camelCase(str) {\n  var words = str.split(wordSeparatorsRegEx);\n  var len = words.length;\n  var mappedWords = new Array(len);\n  for (var i = 0; i < len; i++) {\n    var word = words[i];\n    if (word === '') {\n      continue;\n    }\n    var isCamelCase = basicCamelRegEx.test(word) && !allCapsRegEx.test(word);\n    if (isCamelCase) {\n      word = word.replace(fourOrMoreConsecutiveCapsRegEx, function(match, p1, offset) {\n        return deCap(match, word.length - offset - match.length == 0);\n      });\n    }\n    var firstLetter = word[0];\n    firstLetter = i > 0 ? firstLetter.toUpperCase() : firstLetter.toLowerCase();\n    mappedWords[i] = firstLetter + (!isCamelCase ? word.slice(1).toLowerCase() : word.slice(1));\n  }\n  return mappedWords.join('');\n}\n\nfunction deCap(match, endOfWord) {\n  var arr = match.split('');\n  var first = arr.shift().toUpperCase();\n  var last = endOfWord ? arr.pop().toLowerCase() : arr.pop();\n  return first + arr.join('').toLowerCase() + last;\n}\n\nexport {stringCamelCase as default};\n","import { debugStack, jsco_assert } from '../utils/assert';\nimport { resolveComponentExport } from './component-exports';\nimport { resolveComponentAliasInstanceExport } from './component-functions';\nexport const resolveComponentType = (rctx, rargs) => {\n    const coreInstance = rargs.element;\n    if (!coreInstance) {\n        throw new Error('Wrong element type ');\n    }\n    switch (coreInstance.tag) {\n        case \"ComponentSection\" /* ModelTag.ComponentSection */: return resolveComponentSection(rctx, rargs);\n        case \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */: return resolveComponentAliasInstanceExport(rctx, rargs);\n        default: throw new Error(`\"${coreInstance.tag}\" not implemented`);\n    }\n};\nexport const resolveComponentSection = (rctx, rargs) => {\n    const componentSection = rargs.element;\n    jsco_assert(componentSection && componentSection.tag == \"ComponentSection\" /* ModelTag.ComponentSection */, () => `Wrong element type '${componentSection?.tag}'`);\n    const exportResolutions = [];\n    for (const declaration of componentSection.sections) {\n        switch (declaration.tag) {\n            case \"ComponentExport\" /* ModelTag.ComponentExport */: {\n                if (declaration.kind === \"func\" /* ComponentExternalKind.Func */) {\n                    const exportResolution = resolveComponentExport(rctx, { element: declaration, callerElement: declaration });\n                    exportResolutions.push(exportResolution);\n                }\n                else if (declaration.kind !== \"type\" /* ComponentExternalKind.Type */) {\n                    throw new Error('Not implemented');\n                }\n                break;\n            }\n            case \"ComponentImport\" /* ModelTag.ComponentImport */: {\n                // declaration.name\n                // declaration.name.name\n                // rctx.indexes.componentTypes[declaration.ty.value];\n                // throw new Error('Not implemented' + declaration.name.name);\n                break;\n            }\n            case \"ComponentTypeFunc\" /* ModelTag.ComponentTypeFunc */:\n            case \"ComponentTypeDefinedRecord\" /* ModelTag.ComponentTypeDefinedRecord */:\n            case \"ComponentTypeDefinedTuple\" /* ModelTag.ComponentTypeDefinedTuple */:\n            case \"ComponentTypeDefinedEnum\" /* ModelTag.ComponentTypeDefinedEnum */:\n            case \"ComponentTypeDefinedVariant\" /* ModelTag.ComponentTypeDefinedVariant */:\n                // TODO types\n                break;\n            default:\n                throw new Error(`${declaration.tag} not implemented`);\n        }\n    }\n    return {\n        callerElement: rargs.callerElement,\n        element: componentSection,\n        binder: async (bctx, bargs) => {\n            const exports = {};\n            for (const exportResolution of exportResolutions) {\n                const callerElement = exportResolution.callerElement;\n                const args = {\n                    arguments: bargs.arguments,\n                    imports: bargs.imports,\n                    callerArgs: bargs,\n                    debugSource: callerElement.tag + ':' + callerElement.name.name\n                };\n                debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n                debugStack(args, args, callerElement.tag + ':' + callerElement.name.name);\n                const argResult = await exportResolution.binder(bctx, args);\n                exports[callerElement.name.name] = argResult.result;\n            }\n            const binderResult = {\n                result: exports\n            };\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=component-types.js.map","import camelCase from 'just-camel-case';\nimport { debugStack, jsco_assert } from '../utils/assert';\nimport { resolveComponentFunction } from './component-functions';\nimport { resolveComponentType } from './component-types';\nexport const resolveComponentInstance = (rctx, rargs) => {\n    const coreInstance = rargs.element;\n    switch (coreInstance.tag) {\n        case \"ComponentInstanceInstantiate\" /* ModelTag.ComponentInstanceInstantiate */: return resolveComponentInstanceInstantiate(rctx, rargs);\n        // case ModelTag.ComponentInstanceFromExports: return resolveComponentInstanceFromExports(rctx, rargs as any);\n        case \"ComponentTypeInstance\" /* ModelTag.ComponentTypeInstance */: return resolveComponentTypeInstance(rctx, rargs);\n        default: throw new Error(`\"${coreInstance.tag}\" not implemented`);\n    }\n};\nexport const resolveComponentInstanceInstantiate = (rctx, rargs) => {\n    const componentInstanceInstantiate = rargs.element;\n    jsco_assert(componentInstanceInstantiate && componentInstanceInstantiate.tag == \"ComponentInstanceInstantiate\" /* ModelTag.ComponentInstanceInstantiate */, () => `Wrong element type '${componentInstanceInstantiate?.tag}'`);\n    const componentSectionIndex = componentInstanceInstantiate.component_index;\n    const componentSection = rctx.indexes.componentTypes[componentSectionIndex];\n    const componentSectionResolution = resolveComponentType(rctx, { element: componentSection, callerElement: componentInstanceInstantiate });\n    const argResolutions = [];\n    for (const arg of componentInstanceInstantiate.args) {\n        switch (arg.kind) {\n            case \"func\" /* ComponentExternalKind.Func */: {\n                const componentFunction = rctx.indexes.componentFunctions[arg.index];\n                const resolver = resolveComponentFunction(rctx, { element: componentFunction, callerElement: arg });\n                argResolutions.push(resolver);\n                break;\n            }\n            case \"instance\" /* ComponentExternalKind.Instance */: {\n                const componentInstance = rctx.indexes.componentInstances[arg.index];\n                const resolver = resolveComponentInstance(rctx, { element: componentInstance, callerElement: arg });\n                argResolutions.push(resolver);\n                break;\n            }\n            case \"type\" /* ComponentExternalKind.Type */: {\n                // TODO types\n                break;\n            }\n            case \"component\" /* ComponentExternalKind.Component */:\n            case \"module\" /* ComponentExternalKind.Module */:\n            case \"value\" /* ComponentExternalKind.Value */:\n            default:\n                throw new Error(`\"${arg.kind}\" not implemented`);\n        }\n    }\n    return {\n        callerElement: rargs.callerElement,\n        element: componentInstanceInstantiate,\n        binder: async (bctx, bargs) => {\n            const binderResult = lookupComponentInstance(bctx, componentInstanceInstantiate.selfSortIndex);\n            Object.assign(binderResult.result, bargs.imports);\n            const componentArgs = {};\n            for (const argResolution of argResolutions) {\n                const callerElement = argResolution.callerElement;\n                const args = {\n                    arguments: bargs.arguments,\n                    imports: bargs.imports,\n                    callerArgs: bargs,\n                };\n                debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n                debugStack(args, args, 'ComponentInstantiationArg:' + callerElement.index + ':' + callerElement.name);\n                const argResult = await argResolution.binder(bctx, args);\n                let argName = callerElement.name;\n                // TODO is this prefix a convention ?\n                if (argName.startsWith('import-func-')) {\n                    argName = argName.substring('import-func-'.length);\n                }\n                argName = camelCase(argName);\n                componentArgs[argName] = argResult.result;\n            }\n            Object.assign(binderResult.result.exports, componentArgs);\n            const args = {\n                imports: componentArgs,\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            const componentSectionResult = await componentSectionResolution.binder(bctx, args);\n            binderResult.result = componentSectionResult.result;\n            return binderResult;\n        }\n    };\n};\nexport const resolveComponentTypeInstance = (rctx, rargs) => {\n    const componentTypeInstance = rargs.element;\n    jsco_assert(componentTypeInstance && componentTypeInstance.tag == \"ComponentTypeInstance\" /* ModelTag.ComponentTypeInstance */, () => `Wrong element type '${componentTypeInstance?.tag}'`);\n    return {\n        callerElement: rargs.callerElement,\n        element: componentTypeInstance,\n        binder: async (bctx, bargs) => {\n            const binderResult = lookupComponentInstance(bctx, componentTypeInstance.selfSortIndex);\n            Object.assign(binderResult.result.exports, bargs.imports);\n            Object.assign(binderResult.result.types, componentTypeInstance.declarations);\n            return binderResult;\n        }\n    };\n};\nexport function lookupComponentInstance(bctx, instanceIndex) {\n    let binderResult = bctx.componentInstances[instanceIndex];\n    if (!binderResult) {\n        binderResult = {\n            result: {\n                instanceIndex,\n                imports: {},\n                exports: {},\n                types: {}\n            }\n        };\n        bctx.componentInstances[instanceIndex] = binderResult;\n    }\n    return binderResult;\n}\n//# sourceMappingURL=component-instances.js.map","import { jsco_assert } from '../utils/assert';\nexport const resolveCoreModule = (rctx, rargs) => {\n    const coreModule = rargs.element;\n    jsco_assert(coreModule && coreModule.tag == \"CoreModule\" /* ModelTag.CoreModule */, () => `Wrong element type '${coreModule?.tag}'`);\n    return {\n        callerElement: rargs.callerElement,\n        element: coreModule,\n        binder: async (bctx, bargs) => {\n            const binderResult = {\n                result: await coreModule.module\n            };\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=core-module.js.map","import { debugStack, jsco_assert } from '../utils/assert';\nimport { resolveCoreFunction } from './core-functions';\nimport { resolveCoreModule } from './core-module';\nexport const resolveCoreInstance = (rctx, rargs) => {\n    const coreInstance = rargs.element;\n    switch (coreInstance.tag) {\n        case \"CoreInstanceFromExports\" /* ModelTag.CoreInstanceFromExports */: return resolveCoreInstanceFromExports(rctx, rargs);\n        case \"CoreInstanceInstantiate\" /* ModelTag.CoreInstanceInstantiate */: return resolveCoreInstanceInstantiate(rctx, rargs);\n        default: throw new Error(`\"${coreInstance.tag}\" not implemented`);\n    }\n};\nexport const resolveCoreInstanceFromExports = (rctx, rargs) => {\n    const coreInstanceFromExports = rargs.element;\n    jsco_assert(coreInstanceFromExports && coreInstanceFromExports.tag == \"CoreInstanceFromExports\" /* ModelTag.CoreInstanceFromExports */, () => `Wrong element type '${coreInstanceFromExports?.tag}'`);\n    const exportResolutions = [];\n    for (const exp of coreInstanceFromExports.exports) {\n        switch (exp.kind) {\n            case \"func\" /* ExternalKind.Func */: {\n                const func = rctx.indexes.coreFunctions[exp.index];\n                const exportResolution = resolveCoreFunction(rctx, { element: func, callerElement: exp });\n                exportResolutions.push(exportResolution);\n                break;\n            }\n            case \"table\" /* ExternalKind.Table */: {\n                const table = rctx.indexes.coreTables[exp.index];\n                const exportResolution = resolveCoreFunction(rctx, { element: table, callerElement: exp });\n                exportResolutions.push(exportResolution);\n                break;\n            }\n            default:\n                throw new Error(`\"${exp.kind}\" not implemented`);\n        }\n    }\n    return {\n        element: coreInstanceFromExports,\n        callerElement: rargs.callerElement,\n        binder: async (bctx, bargs) => {\n            const exports = {};\n            for (const exportResolution of exportResolutions) {\n                const callerElement = exportResolution.callerElement;\n                const args = {\n                    arguments: bargs.arguments,\n                    imports: bargs.imports,\n                    callerArgs: bargs,\n                };\n                debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n                debugStack(args, args, callerElement.kind + ':' + callerElement.name);\n                const argResult = await exportResolution.binder(bctx, args);\n                exports[callerElement.name] = argResult.result;\n            }\n            const binderResult = {\n                result: exports\n            };\n            return binderResult;\n        }\n    };\n};\nexport const resolveCoreInstanceInstantiate = (rctx, rargs) => {\n    const coreInstanceInstantiate = rargs.element;\n    const coreInstanceIndex = coreInstanceInstantiate.selfSortIndex;\n    jsco_assert(coreInstanceInstantiate && coreInstanceInstantiate.tag == \"CoreInstanceInstantiate\" /* ModelTag.CoreInstanceInstantiate */, () => `Wrong element type '${coreInstanceInstantiate?.tag}'`);\n    const coreModuleIndex = coreInstanceInstantiate.module_index;\n    const coreModule = rctx.indexes.coreModules[coreModuleIndex];\n    const coreModuleResolution = resolveCoreModule(rctx, { element: coreModule, callerElement: coreInstanceInstantiate });\n    const argResolutions = [];\n    for (const arg of coreInstanceInstantiate.args) {\n        switch (arg.kind) {\n            case \"instance\" /* InstantiationArgKind.Instance */: {\n                const argInstance = rctx.indexes.coreInstances[arg.index];\n                const resolution = resolveCoreInstance(rctx, {\n                    callerElement: arg,\n                    element: argInstance\n                });\n                argResolutions.push(resolution);\n                break;\n            }\n            default:\n                throw new Error(`\"${arg.kind}\" not implemented`);\n        }\n    }\n    return {\n        element: coreInstanceInstantiate,\n        callerElement: rargs.callerElement,\n        binder: async (bctx, bargs) => {\n            let binderResult = bctx.coreInstances[coreInstanceIndex];\n            if (binderResult) {\n                // TODO, do I need to validate that all calls got the same args ?\n                return binderResult;\n            }\n            binderResult = {};\n            bctx.coreInstances[coreInstanceIndex] = binderResult;\n            const wasmImports = {\n                debugSource: rargs.element.tag\n            };\n            for (const argResolution of argResolutions) {\n                const callerElement = argResolution.callerElement;\n                const args = {\n                    arguments: bargs.arguments,\n                    imports: bargs.imports,\n                    callerArgs: bargs,\n                };\n                debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n                debugStack(args, args, callerElement.index + ':' + callerElement.name);\n                const argResult = await argResolution.binder(bctx, args);\n                wasmImports[callerElement.name] = argResult.result;\n            }\n            const args = {\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            const moduleResult = await coreModuleResolution.binder(bctx, args);\n            const module = moduleResult.result;\n            const instance = await rctx.wasmInstantiate(module, wasmImports);\n            // console.log('rctx.wasmInstantiate ' + coreInstanceIndex, Object.keys(instance.exports));\n            const exports = instance.exports;\n            // TODO maybe there are WIT instructions telling that explicitly ?\n            const memory = exports['memory'];\n            if (memory) {\n                bctx.initializeMemory(memory);\n            }\n            const cabi_realloc = exports['cabi_realloc'];\n            if (cabi_realloc) {\n                bctx.initializeRealloc(cabi_realloc);\n            }\n            binderResult.result = exports;\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=core-instance.js.map","import { debugStack, jsco_assert } from '../utils/assert';\nimport { createFunctionLowering } from './binding';\nimport { resolveComponentFunction } from './component-functions';\nimport { resolveComponentAliasCoreInstanceExport } from './core-exports';\nexport const resolveCoreFunction = (rctx, rargs) => {\n    const coreInstance = rargs.element;\n    switch (coreInstance.tag) {\n        case \"ComponentAliasCoreInstanceExport\" /* ModelTag.ComponentAliasCoreInstanceExport */: return resolveComponentAliasCoreInstanceExport(rctx, rargs);\n        case \"CanonicalFunctionLower\" /* ModelTag.CanonicalFunctionLower */: return resolveCanonicalFunctionLower(rctx, rargs);\n        default: throw new Error(`\"${coreInstance.tag}\" not implemented`);\n    }\n};\nexport const resolveCanonicalFunctionLower = (rctx, rargs) => {\n    const canonicalFunctionLowerElem = rargs.element;\n    jsco_assert(canonicalFunctionLowerElem && canonicalFunctionLowerElem.tag == \"CanonicalFunctionLower\" /* ModelTag.CanonicalFunctionLower */, () => `Wrong element type '${canonicalFunctionLowerElem?.tag}'`);\n    const componentFuntion = rctx.indexes.componentFunctions[canonicalFunctionLowerElem.func_index];\n    const componentFunctionResolution = resolveComponentFunction(rctx, { element: componentFuntion, callerElement: canonicalFunctionLowerElem });\n    // this is very fake\n    const componentType = rctx.indexes.componentInstances[0];\n    const instanceFunType = componentType.declarations[2];\n    const funcType = instanceFunType.value;\n    //TODO canonicalFunctionLowerElem.options\n    const loweringBinder = createFunctionLowering(rctx, funcType);\n    return {\n        callerElement: rargs.callerElement,\n        element: canonicalFunctionLowerElem,\n        binder: async (bctx, bargs) => {\n            const args = {\n                arguments: bargs.arguments,\n                imports: bargs.imports,\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            debugStack(args, args, componentFuntion.tag + ':' + componentFuntion.selfSortIndex);\n            const functionResult = await componentFunctionResolution.binder(bctx, args);\n            const wasmFunction = loweringBinder(bctx, functionResult.result);\n            const binderResult = {\n                result: wasmFunction\n            };\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=core-functions.js.map","import { debugStack } from '../utils/assert';\nimport { resolveCoreInstance } from './core-instance';\nexport const resolveComponentAliasCoreInstanceExport = (rctx, rargs) => {\n    const componentAliasCoreInstanceExport = rargs.element;\n    const coreInstanceIndex = componentAliasCoreInstanceExport.instance_index;\n    const coreInstance = rctx.indexes.coreInstances[coreInstanceIndex];\n    const coreModuleResolution = resolveCoreInstance(rctx, { element: coreInstance, callerElement: componentAliasCoreInstanceExport });\n    return {\n        callerElement: rargs.callerElement,\n        element: componentAliasCoreInstanceExport,\n        binder: async (bctx, bargs) => {\n            const args = {\n                missing: rargs.element.tag,\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            const moduleResult = await coreModuleResolution.binder(bctx, args);\n            const result = moduleResult.result[componentAliasCoreInstanceExport.name];\n            const binderResult = {\n                result\n            };\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=core-exports.js.map","import { debugStack, jsco_assert } from '../utils/assert';\nimport { createFunctionLifting } from './binding';\nimport { resolveComponentInstance } from './component-instances';\nimport { resolveCoreFunction } from './core-functions';\nimport camelCase from 'just-camel-case';\nexport const resolveComponentFunction = (rctx, rargs) => {\n    const coreInstance = rargs.element;\n    switch (coreInstance.tag) {\n        case \"CanonicalFunctionLift\" /* ModelTag.CanonicalFunctionLift */: return resolveCanonicalFunctionLift(rctx, rargs);\n        case \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */: return resolveComponentAliasInstanceExport(rctx, rargs);\n        default: throw new Error(`\"${coreInstance.tag}\" not implemented`);\n    }\n};\nexport const resolveCanonicalFunctionLift = (rctx, rargs) => {\n    const canonicalFunctionLift = rargs.element;\n    jsco_assert(canonicalFunctionLift && canonicalFunctionLift.tag == \"CanonicalFunctionLift\" /* ModelTag.CanonicalFunctionLift */, () => `Wrong element type '${canonicalFunctionLift?.tag}'`);\n    const coreFuntion = rctx.indexes.coreFunctions[canonicalFunctionLift.core_func_index];\n    const coreFunctionResolution = resolveCoreFunction(rctx, { element: coreFuntion, callerElement: canonicalFunctionLift });\n    const sectionFunType = rctx.indexes.componentTypes[canonicalFunctionLift.type_index];\n    jsco_assert(sectionFunType.tag === \"ComponentTypeFunc\" /* ModelTag.ComponentTypeFunc */, () => `expected ComponentTypeFunc, got ${sectionFunType.tag}`);\n    // TODO canonicalFunctionLift.options\n    const liftingBinder = createFunctionLifting(rctx, sectionFunType);\n    return {\n        callerElement: rargs.callerElement,\n        element: canonicalFunctionLift,\n        binder: async (bctx, bargs) => {\n            const args = {\n                arguments: bargs.arguments,\n                imports: bargs.imports,\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            const functionResult = await coreFunctionResolution.binder(bctx, args);\n            const jsFunction = liftingBinder(bctx, functionResult.result);\n            const binderResult = {\n                result: jsFunction\n            };\n            return binderResult;\n        }\n    };\n};\nexport const resolveComponentAliasInstanceExport = (rctx, rargs) => {\n    const componentAliasInstanceExport = rargs.element;\n    jsco_assert(componentAliasInstanceExport && componentAliasInstanceExport.tag == \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */, () => `Wrong element type '${componentAliasInstanceExport?.tag}'`);\n    if (componentAliasInstanceExport.kind === \"type\" /* ComponentExternalKind.Type */) {\n        // TODO types\n        return {\n            callerElement: rargs.callerElement,\n            element: componentAliasInstanceExport,\n            binder: async (bctx, bargs) => {\n                const binderResult = {\n                    missingRes: rargs.element.tag,\n                    confused: 1,\n                    result: {\n                        missingResTypes: rargs.element.tag,\n                    }\n                };\n                return binderResult;\n            }\n        };\n    }\n    if (componentAliasInstanceExport.kind !== \"func\" /* ComponentExternalKind.Func */) {\n        throw new Error(`\"${componentAliasInstanceExport.kind}\" not implemented`);\n    }\n    const instance = rctx.indexes.componentInstances[componentAliasInstanceExport.instance_index];\n    const instanceResolution = resolveComponentInstance(rctx, { element: instance, callerElement: componentAliasInstanceExport });\n    return {\n        callerElement: rargs.callerElement,\n        element: componentAliasInstanceExport,\n        binder: async (bctx, bargs) => {\n            const args = {\n                arguments: bargs.arguments,\n                imports: bargs.imports,\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            const instanceResult = await instanceResolution.binder(bctx, args);\n            // TODO resolve type as well\n            let fn;\n            const askedName = args.arguments?.[0];\n            if (askedName) {\n                fn = instanceResult.result.exports[askedName];\n            }\n            else {\n                const ccName = camelCase(componentAliasInstanceExport.name);\n                fn = instanceResult.result.imports[ccName];\n            }\n            const binderResult = {\n                result: fn\n            };\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=component-functions.js.map","import { debugStack, jsco_assert } from '../utils/assert';\nimport { resolveComponentFunction } from './component-functions';\nimport { resolveComponentInstance } from './component-instances';\nexport const resolveComponentExport = (rctx, rargs) => {\n    const componentExport = rargs.element;\n    jsco_assert(componentExport && componentExport.tag == \"ComponentExport\" /* ModelTag.ComponentExport */, () => `Wrong element type '${componentExport?.tag}'`);\n    // TODO componentExport.ty ?\n    switch (componentExport.kind) {\n        case \"func\" /* ComponentExternalKind.Func */: {\n            const func = rctx.indexes.componentFunctions[componentExport.index];\n            const functionResolution = resolveComponentFunction(rctx, { element: func, callerElement: componentExport });\n            return {\n                callerElement: rargs.callerElement,\n                element: componentExport,\n                binder: async (bctx, bargs) => {\n                    const args = {\n                        arguments: [componentExport.name.name],\n                        imports: bargs.imports,\n                        callerArgs: bargs,\n                    };\n                    debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.name.name + ':' + rargs.element.kind);\n                    const exportResult = await functionResolution.binder(bctx, args);\n                    const binderResult = {\n                        result: exportResult.result\n                    };\n                    return binderResult;\n                }\n            };\n        }\n        case \"instance\" /* ComponentExternalKind.Instance */: {\n            const instance = rctx.indexes.componentInstances[componentExport.index];\n            const instanceResolution = resolveComponentInstance(rctx, { element: instance, callerElement: componentExport });\n            return {\n                callerElement: rargs.callerElement,\n                element: componentExport,\n                binder: async (bctx, bargs) => {\n                    const args = {\n                        arguments: bargs.arguments,\n                        imports: bargs.imports,\n                        callerArgs: bargs,\n                    };\n                    debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.name.name + ':' + rargs.element.kind);\n                    const instanceResult = await instanceResolution.binder(bctx, args);\n                    const ifc = {};\n                    ifc[componentExport.name.name] = instanceResult.result;\n                    const binderResult = {\n                        result: ifc\n                    };\n                    return binderResult;\n                }\n            };\n        }\n        case \"type\" /* ComponentExternalKind.Type */: {\n            throw new Error('TODO types');\n        }\n        case \"component\" /* ComponentExternalKind.Component */:\n        case \"module\" /* ComponentExternalKind.Module */:\n        case \"value\" /* ComponentExternalKind.Value */:\n        default:\n            throw new Error(`${componentExport.kind} not implemented`);\n    }\n};\n//# sourceMappingURL=component-exports.js.map","import { jsco_assert } from '../utils/assert';\nimport { lookupComponentInstance } from './component-instances';\nexport const resolveComponentImport = (rctx, rargs) => {\n    const componentImport = rargs.element;\n    jsco_assert(componentImport && componentImport.tag == \"ComponentImport\" /* ModelTag.ComponentImport */, () => `Wrong element type '${componentImport?.tag}'`);\n    switch (componentImport.ty.tag) {\n        case \"ComponentTypeRefComponent\" /* ModelTag.ComponentTypeRefComponent */: {\n            return {\n                callerElement: rargs.callerElement,\n                element: componentImport,\n                binder: async (bctx, bargs) => {\n                    // TODO this instance index is probably wrong!\n                    const binderResult = lookupComponentInstance(bctx, componentImport.selfSortIndex);\n                    const imprt = bargs.imports[componentImport.name.name];\n                    Object.assign(binderResult.result.imports, imprt);\n                    return binderResult;\n                }\n            };\n        }\n        case \"ComponentTypeRefFunc\" /* ModelTag.ComponentTypeRefFunc */:\n        case \"ComponentTypeRefType\" /* ModelTag.ComponentTypeRefType */:\n        default:\n            throw new Error(`${componentImport.ty.tag} not implemented`);\n    }\n};\n//# sourceMappingURL=component-imports.js.map","import { configuration } from '../utils/assert';\nexport function createResolverContext(sections, options) {\n    const rctx = {\n        usesNumberForInt64: (options.useNumberForInt64 === true) ? true : false,\n        wasmInstantiate: options.wasmInstantiate ?? WebAssembly.instantiate,\n        indexes: {\n            componentExports: [],\n            componentImports: [],\n            componentFunctions: [],\n            componentInstances: [],\n            componentTypes: [],\n            componentTypeResource: [],\n            coreModules: [],\n            coreInstances: [],\n            coreFunctions: [],\n            coreMemories: [],\n            coreTables: [],\n            coreGlobals: [],\n            componentSections: [],\n        },\n    };\n    const indexes = rctx.indexes;\n    for (const section of sections) {\n        // TODO: process all sections into model\n        const bucket = bucketByTag(rctx, section.tag, false, section.kind);\n        bucket.push(section);\n    }\n    // indexed with imports first and then function definitions next\n    // See https://github.com/bytecodealliance/wasm-interface-types/blob/main/BINARY.md\n    rctx.indexes.componentTypes = [...rctx.indexes.componentSections, ...indexes.componentTypes];\n    setSelfIndex(rctx);\n    return rctx;\n}\nexport function setSelfIndex(rctx) {\n    function setSelfIndex(sort) {\n        for (let i = 0; i < sort.length; i++) {\n            sort[i].selfSortIndex = i;\n        }\n    }\n    setSelfIndex(rctx.indexes.componentExports);\n    setSelfIndex(rctx.indexes.componentImports);\n    setSelfIndex(rctx.indexes.componentFunctions);\n    setSelfIndex(rctx.indexes.componentInstances);\n    setSelfIndex(rctx.indexes.componentTypes);\n    setSelfIndex(rctx.indexes.componentTypeResource);\n    setSelfIndex(rctx.indexes.coreModules);\n    setSelfIndex(rctx.indexes.coreInstances);\n    setSelfIndex(rctx.indexes.coreFunctions);\n    setSelfIndex(rctx.indexes.coreMemories);\n    setSelfIndex(rctx.indexes.coreTables);\n    setSelfIndex(rctx.indexes.coreGlobals);\n}\nexport function createBindingContext(rctx, componentImports) {\n    let memory = undefined;\n    let cabi_realloc = undefined;\n    function initializeMemory(m) {\n        memory = m;\n    }\n    function initializeRealloc(realloc) {\n        cabi_realloc = realloc;\n    }\n    function getView(pointer, len) {\n        return new DataView(memory.buffer, pointer, len);\n    }\n    function getViewU8(pointer, len) {\n        return new Uint8Array(memory.buffer, pointer, len);\n    }\n    function getMemory() {\n        return memory;\n    }\n    function realloc(oldPtr, oldSize, align, newSize) {\n        return cabi_realloc(oldPtr, oldSize, align, newSize);\n    }\n    function alloc(newSize, align) {\n        return cabi_realloc(0, 0, align, newSize);\n    }\n    function readI32(ptr) {\n        return getView().getInt32(ptr);\n    }\n    function writeI32(ptr, value) {\n        return getView().setInt32(ptr, value);\n    }\n    function abort() {\n        throw new Error('not implemented');\n    }\n    const ctx = {\n        componentImports,\n        coreInstances: [],\n        componentInstances: [],\n        utf8Decoder: new TextDecoder(),\n        utf8Encoder: new TextEncoder(),\n        initializeMemory,\n        initializeRealloc,\n        getView,\n        getViewU8,\n        getMemory,\n        realloc,\n        alloc,\n        readI32,\n        writeI32,\n        abort,\n    };\n    if (configuration === 'Debug') {\n        ctx.debugStack = [];\n    }\n    return ctx;\n}\nexport function bucketByTag(rctx, tag, read, kind) {\n    switch (tag) {\n        case \"CoreModule\" /* ModelTag.CoreModule */:\n            return rctx.indexes.coreModules;\n        case \"ComponentExport\" /* ModelTag.ComponentExport */:\n            return rctx.indexes.componentExports;\n        case \"ComponentImport\" /* ModelTag.ComponentImport */:\n            return rctx.indexes.componentImports;\n            break;\n        case \"ComponentAliasCoreInstanceExport\" /* ModelTag.ComponentAliasCoreInstanceExport */: {\n            switch (kind) {\n                case \"func\" /* ExternalKind.Func */:\n                    return rctx.indexes.coreFunctions;\n                case \"table\" /* ExternalKind.Table */:\n                    return rctx.indexes.coreTables;\n                case \"memory\" /* ExternalKind.Memory */:\n                    return rctx.indexes.coreMemories;\n                case \"global\" /* ExternalKind.Global */:\n                    return rctx.indexes.coreGlobals;\n                case \"tag\" /* ExternalKind.Tag */:\n                default:\n                    throw new Error(`unexpected section tag: ${kind}`);\n            }\n            break;\n        }\n        case \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */: {\n            switch (kind) {\n                case \"func\" /* ComponentExternalKind.Func */:\n                    return rctx.indexes.componentFunctions;\n                case \"component\" /* ComponentExternalKind.Component */:\n                    return rctx.indexes.componentTypes;\n                case \"type\" /* ComponentExternalKind.Type */:\n                    return rctx.indexes.componentTypes;\n                case \"module\" /* ComponentExternalKind.Module */:\n                case \"value\" /* ComponentExternalKind.Value */:\n                case \"instance\" /* ComponentExternalKind.Instance */:\n                default:\n                    throw new Error(`unexpected section tag: ${kind}`);\n            }\n        }\n        case \"CoreInstanceFromExports\" /* ModelTag.CoreInstanceFromExports */:\n        case \"CoreInstanceInstantiate\" /* ModelTag.CoreInstanceInstantiate */:\n            return rctx.indexes.coreInstances;\n        case \"ComponentInstanceFromExports\" /* ModelTag.ComponentInstanceFromExports */:\n        case \"ComponentInstanceInstantiate\" /* ModelTag.ComponentInstanceInstantiate */:\n            return rctx.indexes.componentInstances;\n        case \"ComponentTypeFunc\" /* ModelTag.ComponentTypeFunc */:\n            return rctx.indexes.componentTypes;\n        case \"ComponentSection\" /* ModelTag.ComponentSection */:\n            return read\n                ? rctx.indexes.componentTypes\n                : rctx.indexes.componentSections; //append later\n        case \"ComponentTypeDefinedBorrow\" /* ModelTag.ComponentTypeDefinedBorrow */:\n        case \"ComponentTypeDefinedEnum\" /* ModelTag.ComponentTypeDefinedEnum */:\n        case \"ComponentTypeDefinedFlags\" /* ModelTag.ComponentTypeDefinedFlags */:\n        case \"ComponentTypeDefinedList\" /* ModelTag.ComponentTypeDefinedList */:\n        case \"ComponentTypeDefinedOption\" /* ModelTag.ComponentTypeDefinedOption */:\n        case \"ComponentTypeDefinedOwn\" /* ModelTag.ComponentTypeDefinedOwn */:\n        case \"ComponentTypeDefinedPrimitive\" /* ModelTag.ComponentTypeDefinedPrimitive */:\n        case \"ComponentTypeDefinedRecord\" /* ModelTag.ComponentTypeDefinedRecord */:\n        case \"ComponentTypeDefinedResult\" /* ModelTag.ComponentTypeDefinedResult */:\n        case \"ComponentTypeDefinedTuple\" /* ModelTag.ComponentTypeDefinedTuple */:\n        case \"ComponentTypeDefinedVariant\" /* ModelTag.ComponentTypeDefinedVariant */:\n            return rctx.indexes.componentTypes;\n        case \"ComponentTypeInstance\" /* ModelTag.ComponentTypeInstance */:\n            return rctx.indexes.componentInstances;\n        case \"ComponentTypeResource\" /* ModelTag.ComponentTypeResource */:\n            return rctx.indexes.componentTypeResource;\n        case \"CanonicalFunctionLower\" /* ModelTag.CanonicalFunctionLower */: {\n            return rctx.indexes.coreFunctions;\n        }\n        case \"CanonicalFunctionLift\" /* ModelTag.CanonicalFunctionLift */: {\n            return rctx.indexes.componentFunctions;\n        }\n        case \"SkippedSection\" /* ModelTag.SkippedSection */:\n        case \"CustomSection\" /* ModelTag.CustomSection */:\n            return []; //drop\n        case \"ComponentAliasOuter\" /* ModelTag.ComponentAliasOuter */:\n        case \"CanonicalFunctionResourceDrop\" /* ModelTag.CanonicalFunctionResourceDrop */:\n        case \"CanonicalFunctionResourceNew\" /* ModelTag.CanonicalFunctionResourceNew */:\n        case \"CanonicalFunctionResourceRep\" /* ModelTag.CanonicalFunctionResourceRep */:\n        default:\n            throw new Error(`unexpected section tag: ${tag}`);\n    }\n}\nexport function elementByIndex(rctx, template, index) {\n    const bucket = bucketByTag(rctx, template.tag, true, template.kind);\n    return bucket[index];\n}\n//# sourceMappingURL=context.js.map","import { parse } from '../parser';\nimport { isDebug } from '../utils/assert';\nimport { resolveComponentExport } from './component-exports';\nimport { resolveComponentImport } from './component-imports';\nimport { createBindingContext, createResolverContext } from './context';\nimport { resolveCoreInstance } from './core-instance';\nexport async function instantiateComponent(modelOrComponentOrUrl, imports, options) {\n    let input = modelOrComponentOrUrl;\n    if (typeof input !== 'object' || (Array.isArray(input) && input.length != 0 && typeof input[0] !== 'object')) {\n        input = await parse(input, options ?? {});\n    }\n    const component = await createComponent(input, options);\n    return component.instantiate(imports);\n}\nexport async function createComponent(modelOrComponentOrUrl, options) {\n    let input = modelOrComponentOrUrl;\n    if (typeof input !== 'object' || (Array.isArray(input) && input.length != 0 && typeof input[0] !== 'object')) {\n        input = await parse(input, options ?? {});\n    }\n    const rctx = createResolverContext(input, options ?? {});\n    for (const coreModule of rctx.indexes.coreModules) {\n        await coreModule.module;\n    }\n    const coreInstanceResolutions = [];\n    for (const coreInstance of rctx.indexes.coreInstances) {\n        const resolution = resolveCoreInstance(rctx, { element: coreInstance, callerElement: undefined });\n        coreInstanceResolutions.push(resolution);\n    }\n    const componentImportResolutions = [];\n    for (const componentImport of rctx.indexes.componentImports) {\n        const resolution = resolveComponentImport(rctx, { element: componentImport, callerElement: undefined });\n        componentImportResolutions.push(resolution);\n    }\n    const componentExportResolutions = [];\n    for (const componentExport of rctx.indexes.componentExports) {\n        const resolution = resolveComponentExport(rctx, { element: componentExport, callerElement: undefined });\n        componentExportResolutions.push(resolution);\n    }\n    async function instantiate(componentImports) {\n        componentImports = componentImports ?? {};\n        const ctx = createBindingContext(rctx, componentImports);\n        const imports = {};\n        for (const componentImportResolution of componentImportResolutions) {\n            const args = {\n                imports: componentImports\n            };\n            if (isDebug)\n                args['debugStack'] = [];\n            const componentImportResult = await componentImportResolution.binder(ctx, args);\n            Object.assign(imports, componentImportResult.result);\n        }\n        const exports = {};\n        for (const componentExportResolution of componentExportResolutions) {\n            const args = {};\n            if (isDebug)\n                args['debugStack'] = [];\n            const componentExportResult = await componentExportResolution.binder(ctx, args);\n            Object.assign(exports, componentExportResult.result);\n        }\n        // this is magic, because some core instances are not exported, but they are still needed\n        // I think this is about $imports\n        for (const instanceResolution of coreInstanceResolutions) {\n            const args = {};\n            if (isDebug)\n                args['debugStack'] = [];\n            await instanceResolution.binder(ctx, args);\n        }\n        return {\n            exports,\n            abort: ctx.abort,\n        };\n    }\n    const component = {\n        instantiate,\n    };\n    return component;\n}\n//# sourceMappingURL=index.js.map","// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"./.types.d.ts\" />\nimport gitHash from 'env:gitHash';\nimport configuration from 'env:configuration';\nimport { setConfiguration } from './utils/assert';\nexport { parse } from './parser';\nexport { instantiateComponent, createComponent } from './resolver';\nexport { createLifting, createLowering } from './resolver/binding';\nexport function getBuildInfo() {\n    return {\n        gitHash,\n        configuration,\n    };\n}\nsetConfiguration(configuration);\n//# sourceMappingURL=index.js.map"],"names":["jsco_assert","condition","messageFactory","message","Error","configuration","isDebug","debugStack","src","target","position","orig","isNode","process","versions","node","async","getBodyIfResponse","input","body","StreamSource","total","bpos","buf","reader","constructor","stream","this","getReader","pos","fill","need","length","result","read","done","value","start","len","Math","min","subarray","readAvailable","limit","eof","maybebuf","readExact","n","r","Uint8Array","rest","set","skip","subSource","SubSource","subSyncSource","SyncArraySource","close","releaseLock","ArraySource","_pos","items","from","byteLength","Promise","resolve","max","e","reject","delegate","data","checkLimit","needs","remaining","UnsupportedOperationError","prefix","suffix","msg","undefined","super","defError","SEMAPHORE","Symbol","NO_OP","Reduced","val","deref","isReduced","x","unreduced","iterator1","xform","xs","reduce","fn","implementsFunction","_","y","wasm","U8","window","global","inst","WebAssembly","Instance","Module","base64Decode","rfn","bc","bs","acc","reduced","indexOf","compR","exports","memory","buffer","decodeULEB128","idx","unsupported","BigInt","asUintN","textDecoder","TextDecoder","readU32","source","decoder","i","maxLen","b","push","readRawInteger","consumed","bits","Number","readInteger","leb.decodeULEB128","readStringArray","count","arr","readName","content","decode","parseAsExternalKind","k1","readComponentExternalKind","parseAsComponentExternalKind","k2","toString","readInstanceTypeDeclarations","declarations","declaration","tag","readComponentType","name","readComponentExternName","ty","readComponentTypeRef","type","readDestructor","readComponentInstantiationArgs","args","kind","index","readCoreInstance","module_index","readInstantiationArgs","readExports","readInstantiationArgKind","readCanonicalFunction","controlByte","core_func_index","options","readCanonicalOptions","type_index","func_index","resource","optionsCount","readCanonicalOption","rep","dtor","params","readNamedValues","results","readComponentFuncResult","ok","readComponentValType","err","members","variants","refines","readComponentTypeDefined","readTypeBounds","values","parsePrimitiveValType","parseAsComponentOuterAliasKind","ceil","parseSectionExport","ctx","sections","section","parseAliasTarget","b1","b2","instance_index","WIT_MAGIC","WIT_VERSION","WIT_LAYER","parse","componentOrUrl","url","isFileUrl","startsWith","isHttpUrl","import","then","fs","readFile","globalThis","fetch","fetchLike","checkPreamble","otherSectionData","compileStreaming","processCustomSection","model","parseSection","s","parseWIT","magic","version","layer","every","v","size","readRawIntegerAsync","readIntegerAsync","readU32Async","asyncSub","sub","nameSize","parseSectionCustom","res","whileReading","response","resolveWhenDoneReading","rs","ReadableStream","pull","controller","copy","slice","enqueue","headers","Headers","append","Response","status","statusText","toWasmResponse","module","parseModule","coreInstances","coreInstance","parseSectionCoreInstance","end","parseSectionComponent","component_index","parseSectionInstance","aliases","alias","parseSectionAlias","parseSectionType","canonFunctions","canonicalFun","parseSectionCanon","parseSectionImport","skipSection","absoluteActual","absoluteExpected","hex","t","padStart","JSON","stringify","memoizeCache","Map","memoize","key","factory","get","createLowering","rctx","typeModel","pointer","view","getView","utf8Decoder","spill","createStringLowering","createLifting","srcJsValue","str","TypeError","allocLen","ptr","writtenTotal","realloc","written","utf8Encoder","encodeInto","getViewU8","usesNumberForInt64","num","asIntN","resolved","indexes","componentInstances","recordModel","lifters","member","lifter","srcJsRecord","wasmValue","createRecordLifting","componentTypes","stringCamelCase","words","split","wordSeparatorsRegEx","mappedWords","Array","word","isCamelCase","basicCamelRegEx","test","allCapsRegEx","replace","fourOrMoreConsecutiveCapsRegEx","match","p1","offset","deCap","firstLetter","toUpperCase","toLowerCase","join","endOfWord","first","shift","last","pop","resolveComponentInstance","rargs","element","resolveComponentInstanceInstantiate","resolveComponentTypeInstance","componentInstanceInstantiate","componentSectionIndex","componentSectionResolution","componentSection","exportResolutions","exportResolution","resolveComponentExport","callerElement","binder","bctx","bargs","arguments","imports","callerArgs","debugSource","selfSortIndex","argResult","resolveComponentSection","resolveComponentAliasInstanceExport","resolveComponentType","argResolutions","arg","componentFunction","componentFunctions","resolver","resolveComponentFunction","componentInstance","binderResult","lookupComponentInstance","Object","assign","componentArgs","argResolution","argName","substring","camelCase","componentSectionResult","componentTypeInstance","types","instanceIndex","resolveCoreInstance","resolveCoreInstanceFromExports","resolveCoreInstanceInstantiate","coreInstanceFromExports","exp","func","coreFunctions","resolveCoreFunction","table","coreTables","coreInstanceInstantiate","coreInstanceIndex","coreModuleIndex","coreModuleResolution","coreModule","resolveCoreModule","coreModules","argInstance","resolution","wasmImports","wasmInstantiate","initializeMemory","cabi_realloc","initializeRealloc","componentAliasCoreInstanceExport","missing","resolveComponentAliasCoreInstanceExport","resolveCanonicalFunctionLower","canonicalFunctionLowerElem","componentFuntion","componentFunctionResolution","loweringBinder","exportModel","jsFunction","paramLowerers","param","lowerer","resultLifters","covertedArgs","converted","resJs","createFunctionLowering","functionResult","resolveCanonicalFunctionLift","canonicalFunctionLift","coreFuntion","coreFunctionResolution","sectionFunType","liftingBinder","importModel","paramLifters","resultLowerers","wasmFunction","createFunctionLifting","componentAliasInstanceExport","missingRes","confused","missingResTypes","instance","instanceResolution","instanceResult","askedName","ccName","componentExport","functionResolution","ifc","resolveComponentImport","componentImport","imprt","bucketByTag","componentExports","componentImports","coreMemories","coreGlobals","componentSections","componentTypeResource","instantiateComponent","modelOrComponentOrUrl","isArray","createComponent","instantiate","useNumberForInt64","setSelfIndex","sort","createResolverContext","coreInstanceResolutions","componentImportResolutions","componentExportResolutions","DataView","TextEncoder","m","getMemory","oldPtr","oldSize","align","newSize","alloc","readI32","getInt32","writeI32","setInt32","abort","createBindingContext","componentImportResolution","componentImportResult","componentExportResolution","componentExportResult","getBuildInfo","gitHash"],"mappings":"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","x_google_ignoreList":[3,4,5,6,7,8,9,10,11,12,13,14,29]}