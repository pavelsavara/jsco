{"version":3,"file":"index.js","sources":["https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e//assert.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e//fetch-like.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e//streaming.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/checks/has-wasm.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/errors/unsupported.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/errors/deferror.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/api/api.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/transducers/ensure.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/checks/implements-function.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/transducers/reduced.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/transducers/iterator.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/leb128/index.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/transducers-binary/base64.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/transducers/compr.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/les/@thi.ng/leb128/binary.js","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/values.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/export.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/module.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/alias.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/index.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/otherSection.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/coreInstance.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/instance.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/type.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/canon.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/r/import.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/binding/cache.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/binding/to-js.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/binding/to-abi.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/core-module.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/core-instance.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/core-functions.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/core-exports.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/component-functions.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/component-types.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/component-instances.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/component-exports.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/context.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/ver/index.ts","https://raw.githubusercontent.com/pavelsavara/jsco/8a28011f7c1c6ac4ede9aff1d9f3a68994db614e/.ts"],"sourcesContent":["// TODO inline rollup macro\nexport function jsco_assert(condition, messageFactory) {\n    if (condition)\n        return;\n    const message = 'Assert failed: ' + (typeof messageFactory === 'function'\n        ? messageFactory()\n        : messageFactory);\n    throw new Error(message);\n}\n// TODO figure out how to get jest to use virtual modules\nexport let configuration = 'Debug';\nexport let isDebug = false;\nexport function setConfiguration(value) {\n    configuration = value;\n    isDebug = value === 'Debug';\n}\nexport function debugStack(src, target, position) {\n    if (!isDebug)\n        return;\n    const orig = src['debugStack'] ?? [];\n    target['debugStack'] = [position, ...(orig)];\n}\n//# sourceMappingURL=assert.js.map","const isNode = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';\nexport function fetchLike(url) {\n    const isFileUrl = url.startsWith('file://');\n    const isHttpUrl = url.startsWith('https://') || url.startsWith('http://');\n    if (isNode && (isFileUrl || !isHttpUrl)) {\n        return import('fs/promises').then((fs) => {\n            return fs.readFile(url);\n        });\n    }\n    if (typeof globalThis.fetch !== 'function') {\n        throw new Error('globalThis.fetch is not a function');\n    }\n    return globalThis.fetch(url);\n}\nexport async function getBodyIfResponse(input) {\n    if ('length' in input || 'getReader' in input) {\n        return input;\n    }\n    if ('body' in input) {\n        return getBodyIfResponse(input.body);\n    }\n    if ('then' in input) {\n        return getBodyIfResponse(await input);\n    }\n    throw new Error('I got ' + typeof input);\n}\n//# sourceMappingURL=fetch-like.js.map","// adapted from https://github.com/yskszk63/stream-wasm-parser by yusuke suzuki under MIT License\nexport function newSource(items) {\n    if ('getReader' in items) {\n        return new StreamSource(items);\n    }\n    else {\n        return new ArraySource(items);\n    }\n}\nclass StreamSource {\n    total;\n    bpos;\n    buf;\n    reader;\n    constructor(stream) {\n        this.total = 0;\n        this.bpos = 0;\n        this.buf = null;\n        this.reader = stream.getReader();\n    }\n    get pos() {\n        return this.total;\n    }\n    async fill(need) {\n        if (this.buf === null || this.buf.length - this.bpos < 1) {\n            const result = await this.reader.read();\n            if (result.done) {\n                return 'EOF';\n            }\n            this.buf = result.value;\n            this.bpos = 0;\n        }\n        const start = this.bpos;\n        const len = Math.min(this.buf.length - start, need);\n        this.bpos += len;\n        this.total += len;\n        return this.buf.subarray(start, start + len);\n    }\n    async readAvailable(limit) {\n        if (this.buf === null || this.buf.length - this.bpos < 1) {\n            const result = await this.reader.read();\n            if (result.done) {\n                return null;\n            }\n            this.buf = result.value;\n            this.bpos = 0;\n        }\n        const start = this.bpos;\n        const len = Math.min(this.buf.length - start, limit);\n        this.bpos += len;\n        this.total += len;\n        return this.buf.subarray(start, start + len);\n    }\n    async read(eof) {\n        const maybebuf = await this.fill(1);\n        if (maybebuf === 'EOF') {\n            if (eof === true) {\n                return null;\n            }\n            else {\n                throw new Error('unexpected EOF.');\n            }\n        }\n        return maybebuf[0];\n    }\n    async readExact(n) {\n        const r = new Uint8Array(n);\n        let rest = n;\n        while (rest > 0) {\n            const maybebuf = await this.fill(rest);\n            if (maybebuf === 'EOF') {\n                throw new Error('unexpected EOF.');\n            }\n            r.set(maybebuf, r.length - rest);\n            rest -= maybebuf.length;\n        }\n        return r;\n    }\n    async skip(n) {\n        if (n < 0) {\n            throw new Error('illegal argument.');\n        }\n        let rest = n;\n        while (rest > 0) {\n            const maybebuf = await this.fill(rest);\n            if (maybebuf === 'EOF') {\n                throw new Error('unexpected EOF.');\n            }\n            rest -= maybebuf.length;\n        }\n    }\n    subSource(limit) {\n        return new SubSource(this, limit);\n    }\n    async subSyncSource(limit) {\n        const buf = await this.readExact(limit);\n        return new SyncArraySource(buf);\n    }\n    close() {\n        this.reader.releaseLock();\n    }\n}\nclass ArraySource {\n    _pos;\n    items;\n    constructor(items) {\n        this._pos = 0;\n        this.items = Uint8Array.from(items);\n    }\n    get pos() {\n        return this._pos;\n    }\n    readAvailable(limit) {\n        if (this.items.byteLength === 0 || this._pos == this.items.byteLength || limit === 0) {\n            return Promise.resolve(null);\n        }\n        const max = Math.min(this.items.byteLength - this._pos, limit);\n        const r = this.items.subarray(this._pos, this._pos + max);\n        this._pos += r.byteLength;\n        return Promise.resolve(r);\n    }\n    read(eof) {\n        try {\n            if (this.items.length - this._pos < 1) {\n                if (eof) {\n                    return Promise.resolve(null);\n                }\n                else {\n                    throw new Error('unexpected EOF.');\n                }\n            }\n            const r = this.items[this._pos];\n            this._pos += 1;\n            return Promise.resolve(r);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    readExact(n) {\n        try {\n            if (n === 0) {\n                return Promise.resolve(Uint8Array.from([]));\n            }\n            if (n < 1) {\n                throw new Error('illegal argument.');\n            }\n            if (this.items.length - this._pos < n) {\n                throw new Error('unexpected EOF.');\n            }\n            const r = this.items.subarray(this._pos, this._pos + n);\n            this._pos += n;\n            return Promise.resolve(r);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    skip(n) {\n        try {\n            if (n === 0) {\n                return Promise.resolve();\n            }\n            if (n < 1) {\n                throw new Error('illegal argument.');\n            }\n            if (this.items.length - this._pos < n) {\n                throw new Error('unexpected EOF.');\n            }\n            this._pos += n;\n            return Promise.resolve();\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    subSource(limit) {\n        return new SubSource(this, limit);\n    }\n    async subSyncSource(limit) {\n        const buf = await this.readExact(limit);\n        return new SyncArraySource(buf);\n    }\n    close() {\n        // nop\n    }\n}\nclass SubSource {\n    delegate;\n    rest;\n    constructor(delegate, limit) {\n        if (limit < 0) {\n            throw new Error('illegal argument.');\n        }\n        this.delegate = delegate;\n        this.rest = limit;\n    }\n    get pos() {\n        return this.delegate.pos;\n    }\n    async readAvailable(limit) {\n        const max = Math.min(limit, this.rest);\n        const data = await this.delegate.readAvailable(max);\n        if (data) {\n            this.rest -= data.byteLength;\n        }\n        return data;\n    }\n    async read(eof) {\n        this.checkLimit(1);\n        let r;\n        if (eof === true) {\n            r = await this.delegate.read(true);\n        }\n        else {\n            r = await this.delegate.read();\n        }\n        if (r) {\n            this.rest -= 1;\n        }\n        return r;\n    }\n    async readExact(n) {\n        this.checkLimit(n);\n        const r = await this.delegate.readExact(n);\n        this.rest -= r.length;\n        return r;\n    }\n    async skip(n) {\n        this.checkLimit(n);\n        await this.delegate.skip(n);\n        this.rest -= n;\n    }\n    subSource(limit) {\n        return new SubSource(this, limit);\n    }\n    async subSyncSource(limit) {\n        const buf = await this.readExact(limit);\n        return new SyncArraySource(buf);\n    }\n    checkLimit(needs) {\n        if (this.rest < needs) {\n            throw new Error('limit reached.');\n        }\n    }\n}\nclass SyncArraySource {\n    _pos;\n    items;\n    constructor(items) {\n        this._pos = 0;\n        this.items = Uint8Array.from(items);\n    }\n    get pos() {\n        return this._pos;\n    }\n    get remaining() {\n        return this.items.length - this._pos;\n    }\n    read(eof) {\n        if (this.items.length - this._pos < 1) {\n            if (eof) {\n                null;\n            }\n            else {\n                throw new Error('unexpected EOF.');\n            }\n        }\n        const r = this.items[this._pos];\n        this._pos += 1;\n        return r;\n    }\n    readExact(n) {\n        if (n === 0) {\n            return Uint8Array.from([]);\n        }\n        if (n < 1) {\n            throw new Error('illegal argument.');\n        }\n        if (this.items.length - this._pos < n) {\n            throw new Error('unexpected EOF.');\n        }\n        const r = this.items.subarray(this._pos, this._pos + n);\n        this._pos += n;\n        return r;\n    }\n    skip(n) {\n        if (n === 0) {\n            return;\n        }\n        if (n < 1) {\n            throw new Error('illegal argument.');\n        }\n        if (this.items.length - this._pos < n) {\n            throw new Error('unexpected EOF.');\n        }\n        this._pos += n;\n    }\n}\nexport function bufferToHex(data) {\n    return data.reduce((t, x) => t + ' ' + x.toString(16).padStart(2, '0'), '');\n}\n//# sourceMappingURL=streaming.js.map","export const hasWASM = () => (typeof window !== \"undefined\" &&\n    typeof window[\"WebAssembly\"] !== \"undefined\") ||\n    (typeof global !== \"undefined\" &&\n        typeof global[\"WebAssembly\"] !== \"undefined\");\n","import { defError } from \"./deferror.js\";\nexport const UnsupportedOperationError = defError(() => \"unsupported operation\");\nexport const unsupported = (msg) => {\n    throw new UnsupportedOperationError(msg);\n};\n","export const defError = (prefix, suffix = (msg) => (msg !== undefined ? \": \" + msg : \"\")) => class extends Error {\n    constructor(msg) {\n        super(prefix(msg) + suffix(msg));\n    }\n};\n","export const DEFAULT_EPS = 1e-6;\n/**\n * Internal use only. **Do NOT use in user land code!**\n *\n * @internal\n */\nexport const SEMAPHORE = Symbol();\n/**\n * No-effect placeholder function.\n */\nexport const NO_OP = () => { };\n/**\n * Catch-all event ID\n */\nexport const EVENT_ALL = \"*\";\nexport const EVENT_ENABLE = \"enable\";\nexport const EVENT_DISABLE = \"disable\";\n","import { implementsFunction } from \"@thi.ng/checks/implements-function\";\nexport const ensureTransducer = (x) => implementsFunction(x, \"xform\") ? x.xform() : x;\n","export const implementsFunction = (x, fn) => x != null && typeof x[fn] === \"function\";\n","export class Reduced {\n    constructor(val) {\n        this.value = val;\n    }\n    deref() {\n        return this.value;\n    }\n}\nexport const reduced = (x) => new Reduced(x);\nexport const isReduced = (x) => x instanceof Reduced;\nexport const ensureReduced = (x) => x instanceof Reduced ? x : new Reduced(x);\nexport const unreduced = (x) => (x instanceof Reduced ? x.deref() : x);\n","import { NO_OP, SEMAPHORE } from \"@thi.ng/api/api\";\nimport { isIterable } from \"@thi.ng/checks/is-iterable\";\nimport { ensureTransducer } from \"./ensure.js\";\nimport { push } from \"./push.js\";\nimport { isReduced, unreduced } from \"./reduced.js\";\n/**\n * Takes a transducer and input iterable. Returns iterator of\n * transformed results.\n *\n * @param xform -\n * @param xs -\n */\nexport function* iterator(xform, xs) {\n    const rfn = ensureTransducer(xform)(push());\n    const complete = rfn[1];\n    const reduce = rfn[2];\n    for (let x of xs) {\n        const y = reduce([], x);\n        if (isReduced(y)) {\n            yield* unreduced(complete(y.deref()));\n            return;\n        }\n        if (y.length) {\n            yield* y;\n        }\n    }\n    yield* unreduced(complete([]));\n}\n/**\n * Optimized version of {@link iterator} for transducers which are\n * guaranteed to:\n *\n * 1) Only produce none or a single result per input\n * 2) Do not require a `completion` reduction step\n *\n * @param xform -\n * @param xs -\n */\nexport function* iterator1(xform, xs) {\n    const reduce = (ensureTransducer(xform)([NO_OP, NO_OP, (_, x) => x]))[2];\n    for (let x of xs) {\n        let y = reduce(SEMAPHORE, x);\n        if (isReduced(y)) {\n            y = unreduced(y.deref());\n            if (y !== SEMAPHORE) {\n                yield y;\n            }\n            return;\n        }\n        if (y !== SEMAPHORE) {\n            yield y;\n        }\n    }\n}\n/**\n * Helper function used by various transducers to wrap themselves as\n * transforming iterators. Delegates to {@link iterator1} by default.\n *\n * @param xform -\n * @param args -\n * @param impl -\n *\n * @internal\n */\nexport const __iter = (xform, args, impl = iterator1) => {\n    const n = args.length - 1;\n    return isIterable(args[n])\n        ? args.length > 1\n            ? impl(xform.apply(null, args.slice(0, n)), args[n])\n            : impl(xform(), args[0])\n        : undefined;\n};\n","import { hasWASM } from \"@thi.ng/checks/has-wasm\";\nimport { unsupported } from \"@thi.ng/errors/unsupported\";\nimport { base64Decode } from \"@thi.ng/transducers-binary/base64\";\nimport { BINARY } from \"./binary.js\";\nlet wasm;\nlet U8;\nif (hasWASM()) {\n    const inst = new WebAssembly.Instance(new WebAssembly.Module(base64Decode(BINARY)));\n    wasm = inst.exports;\n    // mapped view of the data buffer\n    U8 = new Uint8Array(wasm.memory.buffer, wasm.buf, 16);\n}\nconst ensureWASM = () => !wasm && unsupported(\"WASM module unavailable\");\nconst encode = (op, signed) => (x) => {\n    ensureWASM();\n    const value = signed\n        ? BigInt.asIntN(64, BigInt(x))\n        : BigInt.asUintN(64, BigInt(x));\n    return U8.slice(0, wasm[op](value));\n};\nconst decode = (op, signed) => (src, idx = 0) => {\n    ensureWASM();\n    U8.set(src.subarray(idx, Math.min(idx + 10, src.length)), 0);\n    const value = wasm[op](0, 0);\n    return [\n        signed ? BigInt.asIntN(64, value) : BigInt.asUintN(64, value),\n        U8[0],\n    ];\n};\n/**\n * Encodes signed integer `x` into LEB128 varint format and returns\n * encoded bytes.\n *\n * @param x -\n */\nexport const encodeSLEB128 = encode(\"leb128EncodeI64\", true);\n/**\n * Takes Uint8Array with LEB128 encoded signed varint and an optional\n * start index to decode from. Returns 2-tuple of decoded value and\n * number of bytes consumed. Consumes up to 10 bytes from `src`.\n *\n * @param src -\n * @param idx -\n */\nexport const decodeSLEB128 = decode(\"leb128DecodeI64\", true);\n/**\n * Encodes unsigned integer `x` into LEB128 varint format and returns\n * encoded bytes. Values < 0 will be encoded as zero.\n *\n * @param x -\n */\nexport const encodeULEB128 = encode(\"leb128EncodeU64\", false);\n/**\n * Takes Uint8Array with LEB128 encoded unsigned varint and an optional\n * start index to decode from. Returns 2-tuple of decoded value and\n * number of bytes consumed. Consumes up to 10 bytes from `src`.\n *\n * @param src -\n * @param idx -\n */\nexport const decodeULEB128 = decode(\"leb128DecodeU64\", false);\n","import { compR } from \"@thi.ng/transducers/compr\";\nimport { iterator, iterator1, __iter } from \"@thi.ng/transducers/iterator\";\nimport { isReduced, reduced } from \"@thi.ng/transducers/reduced\";\nconst B64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst B64_SAFE = B64_CHARS.substring(0, 62) + \"-_\";\nexport function base64Decode(src) {\n    return src\n        ? new Uint8Array([...iterator1(base64Decode(), src)])\n        : (rfn) => {\n            const r = rfn[2];\n            let bc = 0, bs = 0;\n            return compR(rfn, (acc, x) => {\n                switch (x) {\n                    case \"-\":\n                        x = \"+\";\n                        break;\n                    case \"_\":\n                        x = \"/\";\n                        break;\n                    case \"=\":\n                        return reduced(acc);\n                    default:\n                }\n                const y = B64_CHARS.indexOf(x);\n                bs = bc & 3 ? (bs << 6) + y : y;\n                if (bc++ & 3) {\n                    acc = r(acc, 255 & (bs >> ((-2 * bc) & 6)));\n                }\n                return acc;\n            });\n        };\n}\nexport function base64Encode(...args) {\n    const iter = __iter(base64Encode, args, iterator);\n    if (iter) {\n        return [...iter].join(\"\");\n    }\n    return ([init, complete, reduce]) => {\n        let state = 0;\n        let b;\n        const opts = { safe: false, buffer: 1024, ...args[0] };\n        const chars = opts.safe ? B64_SAFE : B64_CHARS;\n        const buf = [];\n        return [\n            init,\n            (acc) => {\n                switch (state) {\n                    case 1:\n                        buf.push(chars[(b >> 18) & 0x3f], chars[(b >> 12) & 0x3f], \"=\", \"=\");\n                        break;\n                    case 2:\n                        buf.push(chars[(b >> 18) & 0x3f], chars[(b >> 12) & 0x3f], chars[(b >> 6) & 0x3f], \"=\");\n                        break;\n                    default:\n                }\n                while (buf.length && !isReduced(acc)) {\n                    acc = reduce(acc, buf.shift());\n                }\n                return complete(acc);\n            },\n            (acc, x) => {\n                switch (state) {\n                    case 0:\n                        state = 1;\n                        b = x << 16;\n                        break;\n                    case 1:\n                        state = 2;\n                        b += x << 8;\n                        break;\n                    default:\n                        state = 0;\n                        b += x;\n                        buf.push(chars[(b >> 18) & 0x3f], chars[(b >> 12) & 0x3f], chars[(b >> 6) & 0x3f], chars[b & 0x3f]);\n                        if (buf.length >= opts.buffer) {\n                            for (let i = 0, n = buf.length; i < n && !isReduced(acc); i++) {\n                                acc = reduce(acc, buf[i]);\n                            }\n                            buf.length = 0;\n                        }\n                }\n                return acc;\n            },\n        ];\n    };\n}\n","/**\n * Reducer composition helper, internally used by various transducers\n * during initialization. Takes existing reducer `rfn` (a 3-tuple) and a\n * reducing function `fn`. Returns a new reducer tuple.\n *\n * @remarks\n * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.\n * `fn` accepts values of type `C` and produces interim results of type\n * `B`, which are then (possibly) passed to the \"inner\" `rfn[2]`\n * function. Therefore the resulting reducer takes inputs of `C` and an\n * accumulator of type `A`.\n *\n * It is assumed that `fn` internally calls `rfn[2]` to pass its own\n * results for further processing by the nested reducer `rfn`.\n *\n * @example\n * ```ts\n * compR(rfn, fn)\n * // [rfn[0], rfn[1], fn]\n * ```\n *\n * @param rfn -\n * @param fn -\n */\nexport const compR = (rfn, fn) => [rfn[0], rfn[1], fn];\n","// thing:no-export\n/**\n * Generated @ 2022-12-02T12:00:53Z\n *\n * @internal\n */\nexport const BINARY = \"AGFzbQEAAAABCgJgAX4Bf2AAAX4DBQQAAQABBQMBABEGCQF/AEGAgMAACwdYBgZtZW1vcnkCAA9sZWIxMjhFbmNvZGVVNjQAAANidWYDAA9sZWIxMjhEZWNvZGVVNjQAAQ9sZWIxMjhFbmNvZGVJNjQAAg9sZWIxMjhEZWNvZGVJNjQAAwrBAwRbAQJ/AkAgAEKAAVoEQANAIAFBgIBAayAAp0H/AHEgAEL/AFZBB3RyOgAAIAFBAWohASAAQoABVCAAQgeIIQBFDQALDAELQYCAwAAgADwAAEEBIQELIAFB/wFxC1ECA38CfgNAAkAgAEEBaiECIABBgIBAaywAACIBQf8Aca0gA4YgBIQhBCABQQBODQAgA0IHfCEDIABBCUkgAiEADQELC0GAgMAAIAI6AAAgBAuRAQEDfwJAIABCQH1CgAFaBEBBASECA0AgAkEBcUUNAiABQYCAQGtBAEGAfyAApyICQcAAcSIDRSAAQoABVHEgA0EGdiAAQgeHIgBCf1FxciIDGyACQf8AcXI6AAAgA0UhAiABQQFqIQEMAAsAC0GAgMAAIABCOYinQcAAcSAAp0E/cXI6AABBASEBCyABQf8BcQt+AgN/A35BfyEAA0ACQCAAQQFqIQEgA0IHfCEFIABBgYDAAGotAAAiAEH/AHGtIAOGIASEIQQgAMAiAkEATg0AIAEhACAFIQMgAUEJSQ0BCwtBgIDAACABQQFqOgAAIARCfyAFhkIAIAJBwABxQQZ2G0IAIAFB/wFxQQlJG4QL\";\n","// adapted from https://github.com/yskszk63/stream-wasm-parser by yusuke suzuki under MIT License\nimport * as leb from '@thi.ng/leb128';\nconst textDecoder = new TextDecoder();\nexport async function readU32Async(source) {\n    return await readIntegerAsync(source, 0x00, 4294967295, leb.decodeULEB128);\n}\nexport function readU32(source) {\n    return readInteger(source, 0x00, 4294967295, leb.decodeULEB128);\n}\nexport async function readNameAsync(source) {\n    const length = await readU32(source);\n    const content = await source.readExact(length);\n    return textDecoder.decode(content);\n}\nexport function readStringArray(src) {\n    const count = readU32(src);\n    const arr = [];\n    for (let i = 0; i < count; i++) {\n        arr.push(readName(src));\n    }\n    return arr;\n}\nexport function readName(source) {\n    const length = readU32(source);\n    const content = source.readExact(length);\n    return textDecoder.decode(content);\n}\nexport function parseAsExternalKind(k1) {\n    switch (k1) {\n        case 0x00: return \"func\" /* ExternalKind.Func */;\n        case 0x01: return \"table\" /* ExternalKind.Table */;\n        case 0x02: return \"memory\" /* ExternalKind.Memory */;\n        case 0x03: return \"global\" /* ExternalKind.Global */;\n        case 0x04: return \"tag\" /* ExternalKind.Tag */;\n        default:\n            throw new Error(`unknown external kind. ${k1}`);\n    }\n}\nexport function readComponentExternalKind(src) {\n    const k1 = readU32(src);\n    return (k1 == 0x00)\n        ? parseAsComponentExternalKind(k1, readU32(src))\n        : parseAsComponentExternalKind(k1);\n}\nexport function parseAsComponentExternalKind(k1, k2) {\n    switch (k1) {\n        case 0x00:\n            switch (k2) {\n                case 0x11: return \"module\" /* ComponentExternalKind.Module */;\n                default:\n                    throw new Error(`unknown component external kind 2. ${k2}`);\n            }\n        case 0x01: return \"func\" /* ComponentExternalKind.Func */;\n        case 0x02: return \"value\" /* ComponentExternalKind.Value */;\n        case 0x03: return \"type\" /* ComponentExternalKind.Type */;\n        case 0x04: return \"component\" /* ComponentExternalKind.Component */;\n        case 0x05: return \"instance\" /* ComponentExternalKind.Instance */;\n        default:\n            throw new Error(`unknown component external kind. 0x${k1.toString(16)}`);\n    }\n}\nexport function readInstanceTypeDeclarations(src) {\n    const count = readU32(src);\n    const declarations = [];\n    for (let i = 0; i < count; i++) {\n        const type = src.read();\n        let declaration;\n        switch (type) {\n            case 0x00: {\n                declaration = {\n                    tag: \"InstanceTypeDeclarationCoreType\" /* ModelTag.InstanceTypeDeclarationCoreType */,\n                    value: undefined,\n                };\n                break;\n            }\n            case 0x01: {\n                declaration = {\n                    tag: \"InstanceTypeDeclarationType\" /* ModelTag.InstanceTypeDeclarationType */,\n                    value: readComponentType(src),\n                };\n                break;\n            }\n            case 0x02: {\n                declaration = {\n                    tag: \"InstanceTypeDeclarationAlias\" /* ModelTag.InstanceTypeDeclarationAlias */,\n                    value: undefined,\n                };\n                break;\n            }\n            case 0x04: {\n                declaration = {\n                    tag: \"InstanceTypeDeclarationExport\" /* ModelTag.InstanceTypeDeclarationExport */,\n                    name: readComponentExternName(src),\n                    ty: readComponentTypeRef(src)\n                };\n                break;\n            }\n        }\n        declarations.push(declaration);\n    }\n    return declarations;\n}\nexport function readComponentExternName(src) {\n    const type = readU32(src);\n    switch (type) {\n        case 0x00: return {\n            tag: \"ComponentExternNameKebab\" /* ModelTag.ComponentExternNameKebab */,\n            name: readName(src),\n        };\n        case 0x01: return {\n            tag: \"ComponentExternNameInterface\" /* ModelTag.ComponentExternNameInterface */,\n            name: readName(src),\n        };\n        default:\n            throw new Error(`unknown ComponentExternName. ${type}`);\n    }\n}\nexport function readDestructor(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x00: return undefined;\n        case 0x01: return readU32(src);\n        default: throw new Error('Invalid leading byte in resource destructor');\n    }\n}\nexport function readComponentTypeDefined(src, type) {\n    switch (type) {\n        case 0x68: {\n            return {\n                tag: \"ComponentTypeDefinedBorrow\" /* ModelTag.ComponentTypeDefinedBorrow */,\n                value: readU32(src),\n            };\n        }\n        case 0x69: {\n            return {\n                tag: \"ComponentTypeDefinedOwn\" /* ModelTag.ComponentTypeDefinedOwn */,\n                value: readU32(src),\n            };\n        }\n        case 0x6a: {\n            return {\n                tag: \"ComponentTypeDefinedResult\" /* ModelTag.ComponentTypeDefinedResult */,\n                ok: readComponentValType(src),\n                err: readComponentValType(src),\n            };\n        }\n        case 0x6b: {\n            return {\n                tag: \"ComponentTypeDefinedOption\" /* ModelTag.ComponentTypeDefinedOption */,\n                value: readComponentValType(src),\n            };\n        }\n        case 0x6d: {\n            return {\n                tag: \"ComponentTypeDefinedEnum\" /* ModelTag.ComponentTypeDefinedEnum */,\n                members: readStringArray(src),\n            };\n        }\n        case 0x6e: {\n            return {\n                tag: \"ComponentTypeDefinedFlags\" /* ModelTag.ComponentTypeDefinedFlags */,\n                members: readStringArray(src),\n            };\n        }\n        case 0x6f: {\n            const count = readU32(src);\n            const members = [];\n            for (let i = 0; i < count; i++) {\n                members.push(readComponentValType(src));\n            }\n            return {\n                tag: \"ComponentTypeDefinedTuple\" /* ModelTag.ComponentTypeDefinedTuple */,\n                members: members,\n            };\n        }\n        case 0x70: {\n            return {\n                tag: \"ComponentTypeDefinedList\" /* ModelTag.ComponentTypeDefinedList */,\n                value: readComponentValType(src),\n            };\n        }\n        case 0x71: {\n            const count = readU32(src);\n            const variants = [];\n            for (let i = 0; i < count; i++) {\n                variants.push({\n                    name: readName(src),\n                    ty: readComponentValType(src),\n                    refines: readU32(src),\n                });\n            }\n            return {\n                tag: \"ComponentTypeDefinedVariant\" /* ModelTag.ComponentTypeDefinedVariant */,\n                variants: variants,\n            };\n        }\n        case 0x72: {\n            const count = readU32(src);\n            const members = [];\n            for (let i = 0; i < count; i++) {\n                members.push({\n                    name: readName(src),\n                    type: readComponentValType(src),\n                });\n            }\n            return {\n                tag: \"ComponentTypeDefinedRecord\" /* ModelTag.ComponentTypeDefinedRecord */,\n                members: members,\n            };\n        }\n        default: throw new Error(`Unrecognized type in readComponentTypeDefined: ${type}`);\n    }\n}\nexport function readComponentInstantiationArgs(src) {\n    const count = readU32(src);\n    const args = [];\n    for (let i = 0; i < count; i++) {\n        args.push({\n            name: readName(src),\n            kind: readComponentExternalKind(src),\n            index: readU32(src)\n        });\n    }\n    return args;\n}\nexport function readCoreInstance(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x00: {\n            const index = readU32(src);\n            return {\n                tag: \"CoreInstanceInstantiate\" /* ModelTag.CoreInstanceInstantiate */,\n                module_index: index,\n                args: readInstantiationArgs(src),\n            };\n        }\n        case 0x01: {\n            return {\n                tag: \"CoreInstanceFromExports\" /* ModelTag.CoreInstanceFromExports */,\n                exports: readExports(src),\n            };\n        }\n        default: throw new Error(`Unrecognized type in readCoreInstance: ${type}`);\n    }\n}\nexport function readExports(src) {\n    const count = readU32(src);\n    const exports = [];\n    for (let i = 0; i < count; i++) {\n        const name = readName(src);\n        const kind = readU32(src);\n        const index = readU32(src);\n        exports.push({\n            name: name,\n            kind: parseAsExternalKind(kind),\n            index: index,\n        });\n    }\n    return exports;\n}\nexport function readInstantiationArgs(src) {\n    const count = readU32(src);\n    const args = [];\n    for (let i = 0; i < count; i++) {\n        const name = readName(src);\n        const kind = readInstantiationArgKind(src);\n        const index = readU32(src);\n        args.push({\n            name: name,\n            kind: kind,\n            index: index\n        });\n    }\n    return args;\n}\nexport function readInstantiationArgKind(src) {\n    const kind = src.read();\n    if (kind != 0x12)\n        throw new Error(`Unrecognized kind in readInstantiationArgKind: ${kind}`);\n    return \"instance\" /* InstantiationArgKind.Instance */;\n}\nexport function readCanonicalFunction(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x00: {\n            const controlByte = src.read();\n            if (controlByte != 0x00)\n                throw new Error(`Unrecognized byte for CanonicalFunctionLift in readCanonicalFunction: ${controlByte}`);\n            return {\n                tag: \"CanonicalFunctionLift\" /* ModelTag.CanonicalFunctionLift */,\n                core_func_index: readU32(src),\n                options: readCanonicalOptions(src),\n                type_index: readU32(src),\n            };\n        }\n        case 0x01: {\n            const controlByte = src.read();\n            if (controlByte != 0x00)\n                throw new Error(`Unrecognized byte for CanonicalFunctionLower in readCanonicalFunction: ${controlByte}`);\n            return {\n                tag: \"CanonicalFunctionLower\" /* ModelTag.CanonicalFunctionLower */,\n                func_index: readU32(src),\n                options: readCanonicalOptions(src),\n            };\n        }\n        case 0x02: return {\n            tag: \"CanonicalFunctionResourceNew\" /* ModelTag.CanonicalFunctionResourceNew */,\n            resource: readU32(src),\n        };\n        case 0x03: return {\n            tag: \"CanonicalFunctionResourceDrop\" /* ModelTag.CanonicalFunctionResourceDrop */,\n            resource: readU32(src),\n        };\n        case 0x04: return {\n            tag: \"CanonicalFunctionResourceRep\" /* ModelTag.CanonicalFunctionResourceRep */,\n            resource: readU32(src),\n        };\n        default: throw new Error(`Unrecognized type in readCanonicalFunction: ${type}`);\n    }\n}\nexport function readCanonicalOptions(src) {\n    const optionsCount = readU32(src);\n    const options = [];\n    for (let i = 0; i < optionsCount; i++) {\n        options.push(readCanonicalOption(src));\n    }\n    return options;\n}\nexport function readCanonicalOption(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x00: return {\n            tag: \"CanonicalOptionUTF8\" /* ModelTag.CanonicalOptionUTF8 */,\n        };\n        case 0x01: return {\n            tag: \"CanonicalOptionUTF16\" /* ModelTag.CanonicalOptionUTF16 */,\n        };\n        case 0x02: return {\n            tag: \"CanonicalOptionCompactUTF16\" /* ModelTag.CanonicalOptionCompactUTF16 */,\n        };\n        case 0x03: return {\n            tag: \"CanonicalOptionMemory\" /* ModelTag.CanonicalOptionMemory */,\n            value: readU32(src),\n        };\n        case 0x04: return {\n            tag: \"CanonicalOptionRealloc\" /* ModelTag.CanonicalOptionRealloc */,\n            value: readU32(src),\n        };\n        case 0x05: return {\n            tag: \"CanonicalOptionPostReturn\" /* ModelTag.CanonicalOptionPostReturn */,\n            value: readU32(src),\n        };\n        default: throw new Error(`Unrecognized type in readCanonicalOption = ${type}.`);\n    }\n}\nexport function readComponentType(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x3F: {\n            return {\n                tag: \"ComponentTypeResource\" /* ModelTag.ComponentTypeResource */,\n                rep: readU32(src),\n                dtor: readDestructor(src)\n            };\n        }\n        case 0x40: {\n            return {\n                tag: \"ComponentTypeFunc\" /* ModelTag.ComponentTypeFunc */,\n                params: readNamedValues(src),\n                results: readComponentFuncResult(src),\n            };\n        }\n        case 0x41: {\n            return {\n                tag: \"ComponentTypeComponent\" /* ModelTag.ComponentTypeComponent */,\n                declarations: undefined,\n            };\n        }\n        case 0x42: {\n            return {\n                tag: \"ComponentTypeInstance\" /* ModelTag.ComponentTypeInstance */,\n                declarations: readInstanceTypeDeclarations(src),\n            };\n        }\n        default: {\n            return readComponentTypeDefined(src, type);\n        }\n    }\n}\nexport function readComponentTypeRef(src) {\n    const type = readU32(src);\n    switch (type) {\n        case 0x00: return {\n            tag: \"ComponentTypeRefModule\" /* ModelTag.ComponentTypeRefModule */,\n            value: readU32(src),\n        };\n        case 0x01: return {\n            tag: \"ComponentTypeRefFunc\" /* ModelTag.ComponentTypeRefFunc */,\n            value: readU32(src),\n        };\n        case 0x02: return {\n            tag: \"ComponentTypeRefValue\" /* ModelTag.ComponentTypeRefValue */,\n            value: readComponentValType(src),\n        };\n        case 0x03: return {\n            tag: \"ComponentTypeRefType\" /* ModelTag.ComponentTypeRefType */,\n            value: readTypeBounds(src),\n        };\n        case 0x04: return {\n            tag: \"ComponentTypeRefInstance\" /* ModelTag.ComponentTypeRefInstance */,\n            value: readU32(src),\n        };\n        case 0x05: return {\n            tag: \"ComponentTypeRefComponent\" /* ModelTag.ComponentTypeRefComponent */,\n            value: readU32(src),\n        };\n        default:\n            throw new Error(`unknown ComponentExternName. ${type}`);\n    }\n}\nexport function readNamedValues(src) {\n    const values = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        values.push({\n            name: readName(src),\n            type: readComponentValType(src),\n        });\n    }\n    return values;\n}\nexport function readComponentFuncResult(src) {\n    const type = src.read();\n    switch (type) {\n        case 0x00:\n            return {\n                tag: \"ComponentFuncResultUnnamed\" /* ModelTag.ComponentFuncResultUnnamed */,\n                type: readComponentValType(src),\n            };\n        case 0x01:\n            return {\n                tag: \"ComponentFuncResultNamed\" /* ModelTag.ComponentFuncResultNamed */,\n                values: readNamedValues(src),\n            };\n        default: throw new Error(`unknown ComponentFuncResult type: ${type}`);\n    }\n}\nexport function readComponentValType(src) {\n    const b = readU32(src);\n    if (0x73 <= b && b <= 0x7f) {\n        return {\n            tag: \"ComponentValTypePrimitive\" /* ModelTag.ComponentValTypePrimitive */,\n            value: parsePrimitiveValType(b),\n        };\n    }\n    return {\n        tag: \"ComponentValTypeType\" /* ModelTag.ComponentValTypeType */,\n        value: b,\n    };\n}\nexport function readTypeBounds(src) {\n    const b = readU32(src);\n    switch (b) {\n        case 0x00: return {\n            tag: \"TypeBoundsEq\" /* ModelTag.TypeBoundsEq */,\n            value: readU32(src),\n        };\n        case 0x01: return {\n            tag: \"TypeBoundsSubResource\" /* ModelTag.TypeBoundsSubResource */,\n        };\n        default:\n            throw new Error(`unknown type bounds. ${b}`);\n    }\n}\nexport function parsePrimitiveValType(b) {\n    switch (b) {\n        case 0x7f: return \"bool\" /* PrimitiveValType.Bool */;\n        case 0x7e: return \"s8\" /* PrimitiveValType.S8 */;\n        case 0x7d: return \"u8\" /* PrimitiveValType.U8 */;\n        case 0x7c: return \"s16\" /* PrimitiveValType.S16 */;\n        case 0x7b: return \"u16\" /* PrimitiveValType.U16 */;\n        case 0x7a: return \"s32\" /* PrimitiveValType.S32 */;\n        case 0x79: return \"u32\" /* PrimitiveValType.U32 */;\n        case 0x78: return \"s64\" /* PrimitiveValType.S64 */;\n        case 0x77: return \"u64\" /* PrimitiveValType.U64 */;\n        case 0x76: return \"f32\" /* PrimitiveValType.Float32 */;\n        case 0x75: return \"f64\" /* PrimitiveValType.Float64 */;\n        case 0x74: return \"char\" /* PrimitiveValType.Char */;\n        case 0x73: return \"string\" /* PrimitiveValType.String */;\n        default: throw new Error(`unknown primitive val type. ${b}`);\n    }\n}\nexport function parseAsComponentOuterAliasKind(k1, k2) {\n    switch (k1) {\n        case 0x00:\n            switch (k2) {\n                case 0x10: return \"coretype\" /* ComponentOuterAliasKind.CoreType */;\n                case 0x11: return \"coremodule\" /* ComponentOuterAliasKind.CoreModule */;\n                default:\n                    throw new Error(`unknown outer alias kind 2. ${k2}`);\n            }\n        case 0x03: return \"type\" /* ComponentOuterAliasKind.Type */;\n        case 0x04: return \"component\" /* ComponentOuterAliasKind.Component */;\n        default:\n            throw new Error(`unknown outer alias kind. ${k1}`);\n    }\n}\nasync function readIntegerAsync(source, min, max, decoder) {\n    const src = await readRawIntegerAsync(source);\n    const [r, consumed] = decoder(src);\n    if (consumed !== src.length) {\n        throw new Error(`invalid data. ${consumed} !== ${src.length}`);\n    }\n    if (r < min || r > max) {\n        throw new Error(`overflow. ${bits}, ${r}`);\n    }\n    return Number(r);\n}\nfunction readInteger(source, min, max, decoder) {\n    const src = readRawInteger(source);\n    const [r, consumed] = decoder(src);\n    if (consumed !== src.length) {\n        throw new Error(`invalid data. ${consumed} !== ${src.length}`);\n    }\n    if (r < min || r > max) {\n        throw new Error(`overflow. ${bits}, ${r}`);\n    }\n    return Number(r);\n}\nconst bits = 32;\nconst maxLen = Math.ceil(bits / 7) | 0;\nasync function readRawIntegerAsync(source) {\n    const buf = [];\n    for (let i = 0; i < maxLen; i++) {\n        const b = await source.read();\n        buf.push(b);\n        if ((b & 0x80) === 0) {\n            break;\n        }\n    }\n    return Uint8Array.from(buf);\n}\nfunction readRawInteger(source) {\n    const buf = [];\n    for (let i = 0; i < maxLen; i++) {\n        const b = source.read();\n        buf.push(b);\n        if ((b & 0x80) === 0) {\n            break;\n        }\n    }\n    return Uint8Array.from(buf);\n}\n//# sourceMappingURL=values.js.map","import { readU32, readComponentExternalKind, readComponentExternName, readComponentTypeRef } from './values';\n// see also https://github.com/bytecodealliance/wasm-tools/blob/e2af293273db65712b6f31da85f7aa5eb31abfde/crates/wasmparser/src/readers/component/exports.rs#L86\n// https://github.com/WebAssembly/component-model/blob/main/design/mvp/Binary.md#import-and-export-definitions\nexport function parseSectionExport(ctx, src) {\n    const sections = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const section = {\n            tag: \"ComponentExport\" /* ModelTag.ComponentExport */,\n            name: readComponentExternName(src),\n            kind: readComponentExternalKind(src),\n            index: readU32(src),\n            ty: readU32(src) === 0 ? undefined : readComponentTypeRef(src)\n        };\n        sections.push(section);\n    }\n    return sections;\n}\n//# sourceMappingURL=export.js.map","export async function parseModule(ctx, src, size) {\n    const res = {\n        tag: \"CoreModule\" /* ModelTag.CoreModule */,\n    };\n    if (ctx.compileStreaming) {\n        const whileReading = new Promise((resolve) => {\n            const response = toWasmResponse(src, size, resolve);\n            const module = ctx.compileStreaming(response);\n            res.module = module;\n        });\n        await whileReading;\n    }\n    else {\n        const data = await src.readExact(size);\n        res.data = data;\n    }\n    return [res];\n}\nfunction toWasmResponse(src, size, resolveWhenDoneReading) {\n    let remaining = size;\n    const pull = async (controller) => {\n        const data = await src.readAvailable(remaining);\n        if (data === null) {\n            resolveWhenDoneReading(undefined);\n            controller.close();\n        }\n        else {\n            // copy, otherwise WebAssembly.compileStreaming will detach the underlying buffer.\n            const copy = data.slice();\n            controller.enqueue(copy);\n            remaining -= data.length;\n            if (remaining === 0) {\n                resolveWhenDoneReading(undefined);\n                controller.close();\n            }\n        }\n    };\n    const rs = new ReadableStream({\n        type: 'bytes', pull,\n    });\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/wasm');\n    headers.append('Content-Length', '' + size);\n    const response = new Response(rs, {\n        headers,\n        status: 200,\n        statusText: 'OK',\n    });\n    return response;\n}\n//# sourceMappingURL=module.js.map","import { readU32, parseAsExternalKind, parseAsComponentExternalKind, parseAsComponentOuterAliasKind, readName } from './values';\n// see also https://github.com/bytecodealliance/wasm-tools/blob/e2af293273db65712b6f31da85f7aa5eb31abfde/crates/wasmparser/src/readers/component/exports.rs#L86\n// https://github.com/WebAssembly/component-model/blob/main/design/mvp/Binary.md#alias-definitions\nexport function parseSectionAlias(ctx, src) {\n    const count = readU32(src);\n    const aliases = [];\n    for (let i = 0; i < count; i++) {\n        // We don't know what type of alias it is yet, so just read the sort bytes\n        const b1 = readU32(src);\n        const b2 = (b1 === 0) ? readU32(src) : undefined;\n        const alias = parseAliasTarget(src, b1, b2);\n        aliases.push(alias);\n    }\n    return aliases;\n}\nfunction parseAliasTarget(src, b1, b2) {\n    const k1 = readU32(src);\n    switch (k1) {\n        case 0x00:\n            return {\n                tag: \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */,\n                kind: parseAsComponentExternalKind(b1, b2),\n                instance_index: readU32(src),\n                name: readName(src)\n            };\n        case 0x01:\n            return {\n                tag: \"ComponentAliasCoreInstanceExport\" /* ModelTag.ComponentAliasCoreInstanceExport */,\n                kind: parseAsExternalKind(b2),\n                instance_index: readU32(src),\n                name: readName(src)\n            };\n        case 0x02:\n            return {\n                tag: \"ComponentAliasOuter\" /* ModelTag.ComponentAliasOuter */,\n                kind: parseAsComponentOuterAliasKind(b1, b2),\n                count: readU32(src),\n                index: readU32(src)\n            };\n        default:\n            throw new Error(`unknown target type. ${k1}`);\n    }\n}\n//# sourceMappingURL=alias.js.map","import { fetchLike, getBodyIfResponse } from '../utils/fetch-like';\nimport { bufferToHex, newSource } from '../utils/streaming';\nimport { parseSectionCustom, skipSection } from './otherSection';\nimport { parseSectionExport } from './export';\nimport { parseModule } from './module';\nimport { readU32Async } from './values';\nimport { parseSectionAlias } from './alias';\nimport { parseSectionImport } from './import';\nimport { parseSectionType } from './type';\nimport { parseSectionCanon } from './canon';\nimport { parseSectionCoreInstance } from './coreInstance';\nimport { parseSectionInstance } from './instance';\nexport const WIT_MAGIC = [0x00, 0x61, 0x73, 0x6d];\nexport const WIT_VERSION = [0x0D, 0x00];\nexport const WIT_LAYER = [0x01, 0x00];\nexport async function parse(componentOrUrl, options) {\n    let input = componentOrUrl;\n    if (typeof componentOrUrl === 'string') {\n        input = fetchLike(componentOrUrl);\n    }\n    input = await getBodyIfResponse(input);\n    const src = newSource(input);\n    const sections = await parseWIT(src, options);\n    return sections;\n}\nasync function parseWIT(src, options) {\n    try {\n        await checkPreamble(src);\n        const ctx = {\n            otherSectionData: options?.otherSectionData ?? false,\n            compileStreaming: options?.compileStreaming ?? WebAssembly.compileStreaming,\n            processCustomSection: options?.processCustomSection ?? undefined,\n        };\n        const model = [];\n        for (;;) {\n            const sections = await parseSection(ctx, src);\n            if (sections === null) {\n                break;\n            }\n            for (const s of sections) {\n                model.push(s);\n            }\n        }\n        return model;\n    }\n    finally {\n        src.close();\n    }\n}\nasync function checkPreamble(src) {\n    const magic = await src.readExact(WIT_MAGIC.length);\n    const version = await src.readExact(WIT_VERSION.length);\n    const layer = await src.readExact(WIT_LAYER.length);\n    const ok = magic.every((v, i) => v === WIT_MAGIC[i])\n        && version.every((v, i) => v === WIT_VERSION[i])\n        && layer.every((v, i) => v === WIT_LAYER[i]);\n    if (!ok) {\n        throw new Error('unexpected magic, version or layer.');\n    }\n}\nasync function parseSection(ctx, src) {\n    const type = await src.read(true); // byte will be enough for type\n    if (type === null) {\n        return null;\n    }\n    const size = await readU32Async(src);\n    const start = src.pos;\n    const asyncSub = type == 1 || type == 4 ? src.subSource(size) : undefined; // if this is module, we need to stream it\n    const sub = type != 1 && type != 4 ? await src.subSyncSource(size) : undefined; // otherwise it's not worth all the async overhead\n    const sections = await (() => {\n        switch (type) {\n            ///\n            /// https://github.com/WebAssembly/component-model/blob/main/design/mvp/Binary.md#component-definitions\n            ///\n            case 0: return parseSectionCustom(ctx, sub, size);\n            case 1: return parseModule(ctx, asyncSub, size);\n            case 2: return parseSectionCoreInstance(ctx, sub);\n            case 4: return parseSectionComponent(ctx, asyncSub, size);\n            case 5: return parseSectionInstance(ctx, sub);\n            case 6: return parseSectionAlias(ctx, sub);\n            case 7: return parseSectionType(ctx, sub);\n            case 8: return parseSectionCanon(ctx, sub);\n            case 10: return parseSectionImport(ctx, sub);\n            case 11: return parseSectionExport(ctx, sub);\n            //TODO: to implement\n            case 3: // core type - we don't have it in the sample\n            case 9: // start\n                return skipSection(ctx, sub, type, size); // this is all TODO\n            default:\n                throw new Error(`unknown section: ${type}`);\n        }\n    })();\n    if (sub && sub.remaining !== 0) {\n        const absoluteActual = start + sub.pos;\n        const absoluteExpected = start + size;\n        const remaining = sub.remaining;\n        const data = sub.readExact(remaining);\n        const hex = bufferToHex(data);\n        throw new Error(`invalid size after reading section ${type}: \\n`\n            + `actual position: 0x${absoluteActual.toString(16)} vs. expected position 0x${absoluteExpected.toString(16)}, remaining ${remaining}\\n`\n            + `section: ${JSON.stringify(sections)}\\n`\n            + 'remaining: ' + hex);\n    }\n    return sections;\n}\nasync function parseSectionComponent(ctx, src, size) {\n    const end = src.pos + size;\n    await checkPreamble(src);\n    let model = [];\n    for (;;) {\n        if (src.pos == end) {\n            break;\n        }\n        const sections = await parseSection(ctx, src);\n        if (sections === null) {\n            break;\n        }\n        model = [...model, ...sections];\n    }\n    return [{\n            tag: \"ComponentSection\" /* ModelTag.ComponentSection */,\n            sections: model,\n        }];\n}\n//# sourceMappingURL=index.js.map","import { readName } from './values';\nexport function parseSectionCustom(ctx, src, size) {\n    const start = src.pos;\n    const name = readName(src);\n    const nameSize = src.pos - start;\n    const data = src.readExact(size - nameSize);\n    let section = {\n        tag: \"CustomSection\" /* ModelTag.CustomSection */,\n        name,\n        data: ctx.otherSectionData ? data : undefined,\n    };\n    if (ctx.processCustomSection) {\n        section = ctx.processCustomSection(section);\n    }\n    return [section];\n}\nexport function skipSection(ctx, src, type, size) {\n    const data = src.readExact(size);\n    const section = {\n        tag: \"SkippedSection\" /* ModelTag.SkippedSection */,\n        type,\n        data: ctx.otherSectionData ? data : undefined,\n    };\n    return [section];\n}\n//# sourceMappingURL=otherSection.js.map","import { readU32, readCoreInstance } from './values';\nexport function parseSectionCoreInstance(ctx, src) {\n    const coreInstances = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const coreInstance = readCoreInstance(src);\n        coreInstances.push(coreInstance);\n    }\n    return coreInstances;\n}\n//# sourceMappingURL=coreInstance.js.map","import { readU32, readComponentInstantiationArgs } from './values';\nimport { parseSectionExport } from './export';\nexport function parseSectionInstance(ctx, src) {\n    const sections = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const section = (() => {\n            const type = readU32(src);\n            switch (type) {\n                case 0x00: {\n                    return {\n                        tag: \"ComponentInstanceInstantiate\" /* ModelTag.ComponentInstanceInstantiate */,\n                        component_index: readU32(src),\n                        args: readComponentInstantiationArgs(src),\n                    };\n                }\n                case 0x01: {\n                    return {\n                        tag: \"ComponentInstanceFromExports\" /* ModelTag.ComponentInstanceFromExports */,\n                        exports: parseSectionExport(ctx, src)\n                    };\n                }\n                default: throw new Error(`Unrecognized type in parseSectionInstance: ${type}`);\n            }\n        })();\n        sections.push(section);\n    }\n    return sections;\n}\n//# sourceMappingURL=instance.js.map","import { readU32, readComponentType } from './values';\nexport function parseSectionType(ctx, src) {\n    const sections = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const section = readComponentType(src);\n        sections.push(section);\n    }\n    return sections;\n}\n//# sourceMappingURL=type.js.map","import { readU32, readCanonicalFunction } from './values';\nexport function parseSectionCanon(ctx, src) {\n    const canonFunctions = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const canonicalFun = readCanonicalFunction(src);\n        canonFunctions.push(canonicalFun);\n    }\n    return canonFunctions;\n}\n//# sourceMappingURL=canon.js.map","import { readU32, readComponentExternName, readComponentTypeRef } from './values';\nexport function parseSectionImport(ctx, src) {\n    const sections = [];\n    const count = readU32(src);\n    for (let i = 0; i < count; i++) {\n        const section = {\n            tag: \"ComponentImport\" /* ModelTag.ComponentImport */,\n            name: readComponentExternName(src),\n            ty: readComponentTypeRef(src)\n        };\n        sections.push(section);\n    }\n    return sections;\n}\n//# sourceMappingURL=import.js.map","const memoizeCache = new Map();\nexport function memoize(key, factory) {\n    let res = memoizeCache.get(key);\n    if (res !== undefined) {\n        return res;\n    }\n    res = factory();\n    memoizeCache.set(key, res);\n    return res;\n}\n//# sourceMappingURL=cache.js.map","import { memoize } from './cache';\nimport { createLifting } from './to-abi';\nexport function createFunctionLowering(rctx, exportModel) {\n    return memoize(exportModel, () => {\n        return (ctx, jsFunction) => {\n            const paramLowerers = [];\n            for (const param of exportModel.params) {\n                const lowerer = createLowering(rctx, param.type);\n                paramLowerers.push(lowerer);\n            }\n            const resultLifters = [];\n            switch (exportModel.results.tag) {\n                case \"ComponentFuncResultNamed\" /* ModelTag.ComponentFuncResultNamed */: {\n                    for (const res of exportModel.results.values) {\n                        const lifter = createLifting(rctx, res.type);\n                        resultLifters.push(lifter);\n                    }\n                    break;\n                }\n                case \"ComponentFuncResultUnnamed\" /* ModelTag.ComponentFuncResultUnnamed */: {\n                    const lifter = createLifting(rctx, exportModel.results.type);\n                    resultLifters.push(lifter);\n                }\n            }\n            function loweringTrampoline(...args) {\n                let covertedArgs = [];\n                // TODO do not always read spilled stack\n                for (let i = 0; i < paramLowerers.length;) {\n                    const lowerer = paramLowerers[i];\n                    const spill = lowerer.spill;\n                    const values = args.slice(i, i + spill);\n                    const converted = lowerer(ctx, ...values);\n                    i += spill;\n                    covertedArgs = [...covertedArgs, converted];\n                }\n                const resJs = jsFunction(...covertedArgs);\n                if (resultLifters.length === 1) {\n                    resultLifters[0](resJs);\n                }\n            }\n            return loweringTrampoline;\n        };\n    });\n}\nexport function createLowering(rctx, typeModel) {\n    return memoize(typeModel, () => {\n        switch (typeModel.tag) {\n            case \"ComponentValTypePrimitive\" /* ModelTag.ComponentValTypePrimitive */:\n                switch (typeModel.value) {\n                    case \"string\" /* PrimitiveValType.String */:\n                        return createStringLowering(rctx);\n                    default:\n                        throw new Error('Not implemented');\n                }\n            default:\n                throw new Error('Not implemented');\n        }\n    });\n}\nfunction createStringLowering(rctx) {\n    const fn = (ctx, ...args) => {\n        const pointer = args[0];\n        const len = args[1];\n        const view = ctx.getView(pointer, len);\n        const res = ctx.utf8Decoder.decode(view);\n        return res;\n    };\n    fn.spill = 2;\n    return fn;\n}\nfunction createRecordLowering(recordModel) {\n    // receives pointer to record in component model layout\n    return (ctx, ...args) => {\n        // return JS record\n        throw new Error('Not implemented');\n        /* return {\n            ... members\n        } as TRecord\n        */\n    };\n}\n//# sourceMappingURL=to-js.js.map","import { jsco_assert } from '../../utils/assert';\nimport { memoize } from './cache';\nimport { createLowering } from './to-js';\nexport function createFunctionLifting(rctx, importModel) {\n    return memoize(importModel, () => {\n        const paramLifters = [];\n        for (const param of importModel.params) {\n            const lifter = createLifting(rctx, param.type);\n            paramLifters.push(lifter);\n        }\n        const resultLowerers = [];\n        switch (importModel.results.tag) {\n            case \"ComponentFuncResultNamed\" /* ModelTag.ComponentFuncResultNamed */: {\n                for (const res of importModel.results.values) {\n                    const lowerer = createLowering(rctx, res.type);\n                    resultLowerers.push(lowerer);\n                }\n                break;\n            }\n            case \"ComponentFuncResultUnnamed\" /* ModelTag.ComponentFuncResultUnnamed */: {\n                const lowerer = createLowering(rctx, importModel.results.type);\n                resultLowerers.push(lowerer);\n            }\n        }\n        return (ctx, wasmFunction) => {\n            function liftingTrampoline(...args) {\n                let covertedArgs = [];\n                for (let i = 0; i < paramLifters.length; i++) {\n                    const lifter = paramLifters[i];\n                    const value = args[i];\n                    const converted = lifter(ctx, value);\n                    // TODO do not always spill into stack\n                    covertedArgs = [...covertedArgs, ...converted];\n                }\n                const resJs = wasmFunction(...covertedArgs);\n                if (resultLowerers.length === 1) {\n                    resultLowerers[0](resJs);\n                }\n            }\n            return liftingTrampoline;\n        };\n    });\n}\nexport function createLifting(rctx, typeModel) {\n    return memoize(typeModel, () => {\n        switch (typeModel.tag) {\n            case \"ComponentValTypePrimitive\" /* ModelTag.ComponentValTypePrimitive */:\n                switch (typeModel.value) {\n                    case \"string\" /* PrimitiveValType.String */:\n                        return createStringLifting();\n                    case \"u32\" /* PrimitiveValType.U32 */:\n                        return createU32Lifting();\n                    case \"s64\" /* PrimitiveValType.S64 */:\n                        return rctx.usesNumberForInt64\n                            ? createS64LiftingNumber()\n                            : createS64LiftingBigInt();\n                    default:\n                        throw new Error('Not implemented');\n                }\n            case \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */: {\n                const resolved = rctx.indexes.componentInstances[typeModel.instance_index];\n                return createLifting(rctx, resolved);\n            }\n            case \"ComponentTypeInstance\" /* ModelTag.ComponentTypeInstance */: {\n                const resolved = typeModel.declarations[0];\n                return createLifting(rctx, resolved);\n            }\n            case \"InstanceTypeDeclarationType\" /* ModelTag.InstanceTypeDeclarationType */: {\n                const resolved = typeModel.value;\n                jsco_assert(resolved.tag === \"ComponentTypeDefinedRecord\" /* ModelTag.ComponentTypeDefinedRecord */, () => `expected ComponentTypeDefinedRecord, got ${resolved.tag}`);\n                return createRecordLifting(rctx, resolved);\n            }\n            case \"ComponentValTypeType\" /* ModelTag.ComponentValTypeType */: {\n                const resolved = rctx.indexes.componentTypes[typeModel.value];\n                return createLifting(rctx, resolved);\n            }\n            default:\n                //return createRecordLifting(rctx, typeModel.value);\n                throw new Error('Not implemented ' + typeModel.tag);\n        }\n    });\n}\nfunction createRecordLifting(rctx, recordModel) {\n    const lifters = [];\n    for (const member of recordModel.members) {\n        const lifter = createLifting(rctx, member.type);\n        lifters.push({ name: member.name, lifter });\n    }\n    return (ctx, srcJsRecord) => {\n        // this is spilling into stack\n        // TODO allocate on heap\n        let args = [];\n        for (const { name, lifter } of lifters) {\n            const jsValue = srcJsRecord[name];\n            const wasmValue = lifter(ctx, jsValue);\n            args = [...args, ...wasmValue];\n        }\n        return args;\n    };\n    /*return (ctx: BindingContext, srcJsRecord: JsRecord, tgtPointer: Pointer): Pointer => {\n\n        // TODO in which cases ABI expects folding into parent record ?\n        const res = ctx.alloc(recordModel.totalSize, recordModel.alignment);\n\n        let pos = res as any;\n        for (let i = 0; i < recordModel.members.length; i++) {\n            const member = recordModel.members[i];\n            const lifting = lifters[i];\n            const alignment = member.type.alignment as any;\n            const jsValue = srcJsRecord[member.name];\n            // TODO is this correct math ?\n            pos += alignment - 1;\n            pos -= pos % alignment;\n            lifting(ctx, jsValue, pos as Pointer);\n            pos += member.type.totalSize as any;\n        }\n        // write pointer to parent in component model layout\n        if (tgtPointer !== 0) {\n            ctx.writeI32(tgtPointer, res);\n        }\n\n        return [res, recordModel.totalSize];\n    };*/\n}\nfunction createU32Lifting() {\n    return (_, srcJsValue) => {\n        const num = srcJsValue;\n        return [num >>> 0];\n    };\n}\nfunction createS64LiftingNumber() {\n    return (ctx, srcJsValue) => {\n        const num = srcJsValue;\n        return [Number(BigInt.asIntN(52, num))];\n    };\n}\nfunction createS64LiftingBigInt() {\n    return (ctx, srcJsValue) => {\n        const num = srcJsValue;\n        return [BigInt.asIntN(52, num)];\n    };\n}\nfunction createStringLifting() {\n    return (ctx, srcJsValue) => {\n        let str = srcJsValue;\n        if (typeof str !== 'string')\n            throw new TypeError('expected a string');\n        if (str.length === 0) {\n            return [0, 0];\n        }\n        let allocLen = 0;\n        let ptr = 0;\n        let writtenTotal = 0;\n        while (str.length > 0) {\n            ptr = ctx.realloc(ptr, allocLen, 1, allocLen + str.length);\n            allocLen += str.length;\n            const { read, written } = ctx.utf8Encoder.encodeInto(str, ctx.getViewU8(ptr + writtenTotal, allocLen - writtenTotal));\n            writtenTotal += written;\n            str = str.slice(read);\n        }\n        if (allocLen > writtenTotal)\n            ptr = ctx.realloc(ptr, allocLen, 1, writtenTotal);\n        return [ptr, writtenTotal];\n    };\n}\n//# sourceMappingURL=to-abi.js.map","import { isDebug, jsco_assert } from '../utils/assert';\nexport const resolveCoreModule = (rctx, rargs) => {\n    const coreModule = rargs.element;\n    jsco_assert(coreModule && coreModule.tag == \"CoreModule\" /* ModelTag.CoreModule */, () => `Wrong element type '${coreModule?.tag}'`);\n    const coreInstanceIndex = rargs.callerElement.selfSortIndex;\n    return {\n        callerElement: rargs.callerElement,\n        element: coreModule,\n        binder: async (bctx, bargs) => {\n            let binderResult = bctx.coreInstances[coreInstanceIndex];\n            if (binderResult) {\n                // TODO, do I need to validate that all calls got the same args ?\n                return binderResult;\n            }\n            const module = await coreModule.module;\n            const instance = await rctx.wasmInstantiate(module, bargs.arguments);\n            //console.log('rctx.wasmInstantiate ' + coreInstanceIndex, Object.keys(instance.exports));\n            const exports = instance.exports;\n            binderResult = {\n                result: instance\n            };\n            bctx.coreInstances[coreInstanceIndex] = binderResult;\n            // TODO maybe there are WIT instructions telling that explicitly ?\n            const memory = exports['memory'];\n            if (memory) {\n                bctx.initializeMemory(memory);\n            }\n            const cabi_realloc = exports['cabi_realloc'];\n            if (cabi_realloc) {\n                bctx.initializeRealloc(cabi_realloc);\n            }\n            if (isDebug)\n                binderResult['bargs'] = bargs;\n            if (isDebug)\n                binderResult['coreInstanceIndex'] = coreInstanceIndex;\n            if (isDebug)\n                binderResult['coreModuleIndex'] = coreModule.selfSortIndex;\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=core-module.js.map","import { debugStack, isDebug, jsco_assert } from '../utils/assert';\nimport { resolveCoreFunction } from './core-functions';\nimport { resolveCoreModule } from './core-module';\nexport const resolveCoreInstance = (rctx, rargs) => {\n    const coreInstance = rargs.element;\n    switch (coreInstance.tag) {\n        case \"CoreInstanceFromExports\" /* ModelTag.CoreInstanceFromExports */: return resolveCoreInstanceFromExports(rctx, rargs);\n        case \"CoreInstanceInstantiate\" /* ModelTag.CoreInstanceInstantiate */: return resolveCoreInstanceInstantiate(rctx, rargs);\n        default: throw new Error(`\"${coreInstance.tag}\" not implemented`);\n    }\n};\nexport const resolveCoreInstanceFromExports = (rctx, rargs) => {\n    const coreInstanceFromExports = rargs.element;\n    jsco_assert(coreInstanceFromExports && coreInstanceFromExports.tag == \"CoreInstanceFromExports\" /* ModelTag.CoreInstanceFromExports */, () => `Wrong element type '${coreInstanceFromExports?.tag}'`);\n    const exportResolutions = [];\n    for (const exp of coreInstanceFromExports.exports) {\n        switch (exp.kind) {\n            case \"func\" /* ExternalKind.Func */: {\n                const func = rctx.indexes.coreFunctions[exp.index];\n                const exportResolution = resolveCoreFunction(rctx, { element: func, callerElement: exp });\n                exportResolutions.push(exportResolution);\n                break;\n            }\n            case \"table\" /* ExternalKind.Table */: {\n                const table = rctx.indexes.coreTables[exp.index];\n                const exportResolution = resolveCoreFunction(rctx, { element: table, callerElement: exp });\n                exportResolutions.push(exportResolution);\n                break;\n            }\n            default:\n                throw new Error(`\"${exp.kind}\" not implemented`);\n        }\n    }\n    return {\n        element: coreInstanceFromExports,\n        callerElement: rargs.callerElement,\n        binder: async (bctx, bargs) => {\n            const exports = {};\n            for (const exportResolution of exportResolutions) {\n                const callerElement = exportResolution.callerElement;\n                const args = {\n                    arguments: bargs.arguments,\n                    callerArgs: bargs,\n                };\n                debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n                debugStack(args, args, callerElement.kind + ':' + callerElement.name);\n                const argResult = await exportResolution.binder(bctx, args);\n                exports[callerElement.name] = argResult.result;\n                if (isDebug)\n                    exports['arguments-of:' + callerElement.name] = bargs;\n            }\n            const binderResult = {\n                result: exports\n            };\n            if (isDebug)\n                binderResult['arguments'] = bargs;\n            return binderResult;\n        }\n    };\n};\nexport const resolveCoreInstanceInstantiate = (rctx, rargs) => {\n    const coreInstanceInstantiate = rargs.element;\n    jsco_assert(coreInstanceInstantiate && coreInstanceInstantiate.tag == \"CoreInstanceInstantiate\" /* ModelTag.CoreInstanceInstantiate */, () => `Wrong element type '${coreInstanceInstantiate?.tag}'`);\n    const coreModuleIndex = coreInstanceInstantiate.module_index;\n    const coreModule = rctx.indexes.coreModules[coreModuleIndex];\n    const coreModuleResolution = resolveCoreModule(rctx, { element: coreModule, callerElement: coreInstanceInstantiate });\n    const argResolutions = [];\n    for (const arg of coreInstanceInstantiate.args) {\n        switch (arg.kind) {\n            case \"instance\" /* InstantiationArgKind.Instance */: {\n                const argInstance = rctx.indexes.coreInstances[arg.index];\n                const resolution = resolveCoreInstance(rctx, {\n                    callerElement: arg,\n                    element: argInstance\n                });\n                argResolutions.push(resolution);\n                break;\n            }\n            default:\n                throw new Error(`\"${arg.kind}\" not implemented`);\n        }\n    }\n    return {\n        element: coreInstanceInstantiate,\n        callerElement: rargs.callerElement,\n        binder: async (bctx, bargs) => {\n            const wasmImports = {\n                debugSource: rargs.element.tag\n            };\n            for (const argResolution of argResolutions) {\n                const callerElement = argResolution.callerElement;\n                const args = {\n                    arguments: bargs.arguments,\n                    callerArgs: bargs,\n                };\n                debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n                debugStack(args, args, callerElement.index + ':' + callerElement.name);\n                const argResult = await argResolution.binder(bctx, args);\n                const parent = argResolution.callerElement;\n                wasmImports[parent.name] = argResult.result;\n            }\n            const args = {\n                arguments: wasmImports,\n                callerArgs: bargs,\n                aaa: 1\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            const moduleResult = await coreModuleResolution.binder(bctx, args);\n            const binderResult = {\n                result: moduleResult.result\n            };\n            if (isDebug)\n                binderResult['bargs'] = bargs;\n            if (isDebug)\n                binderResult['moduleResult'] = moduleResult;\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=core-instance.js.map","import { debugStack, isDebug, jsco_assert } from '../utils/assert';\nimport { createFunctionLowering } from './binding';\nimport { resolveComponentFunction } from './component-functions';\nimport { resolveComponentAliasCoreInstanceExport } from './core-exports';\nexport const resolveCoreFunction = (rctx, rargs) => {\n    const coreInstance = rargs.element;\n    switch (coreInstance.tag) {\n        case \"ComponentAliasCoreInstanceExport\" /* ModelTag.ComponentAliasCoreInstanceExport */: return resolveComponentAliasCoreInstanceExport(rctx, rargs);\n        case \"CanonicalFunctionLower\" /* ModelTag.CanonicalFunctionLower */: return resolveCanonicalFunctionLower(rctx, rargs);\n        default: throw new Error(`\"${coreInstance.tag}\" not implemented`);\n    }\n};\nexport const resolveCanonicalFunctionLower = (rctx, rargs) => {\n    const canonicalFunctionLowerElem = rargs.element;\n    jsco_assert(canonicalFunctionLowerElem && canonicalFunctionLowerElem.tag == \"CanonicalFunctionLower\" /* ModelTag.CanonicalFunctionLower */, () => `Wrong element type '${canonicalFunctionLowerElem?.tag}'`);\n    const componentFuntion = rctx.indexes.componentFunctions[canonicalFunctionLowerElem.func_index];\n    const componentFunctionResolution = resolveComponentFunction(rctx, { element: componentFuntion, callerElement: canonicalFunctionLowerElem });\n    // this is very fake\n    const componentType = rctx.indexes.componentInstances[0];\n    const instanceFunType = componentType.declarations[2];\n    const funcType = instanceFunType.value;\n    //TODO canonicalFunctionLowerElem.options\n    const loweringBinder = createFunctionLowering(rctx, funcType);\n    return {\n        callerElement: rargs.callerElement,\n        element: canonicalFunctionLowerElem,\n        binder: async (bctx, bargs) => {\n            const args = {\n                arguments: bargs.arguments,\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            debugStack(args, args, componentFuntion.tag + ':' + componentFuntion.selfSortIndex);\n            const functionResult = await componentFunctionResolution.binder(bctx, args);\n            const wasmFunction = loweringBinder(bctx, functionResult.result);\n            const binderResult = {\n                // missingRes: rargs.element.tag,\n                result: wasmFunction\n            };\n            if (isDebug)\n                binderResult['bargs'] = bargs;\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=core-functions.js.map","import { debugStack, isDebug } from '../utils/assert';\nimport { resolveCoreInstance } from './core-instance';\nexport const resolveComponentAliasCoreInstanceExport = (rctx, rargs) => {\n    const componentAliasCoreInstanceExport = rargs.element;\n    const coreInstanceIndex = componentAliasCoreInstanceExport.instance_index;\n    const coreInstance = rctx.indexes.coreInstances[coreInstanceIndex];\n    const coreModuleResolution = resolveCoreInstance(rctx, { element: coreInstance, callerElement: componentAliasCoreInstanceExport });\n    return {\n        callerElement: rargs.callerElement,\n        element: componentAliasCoreInstanceExport,\n        binder: async (bctx, bargs) => {\n            const args = {\n                arguments: { missingArgEx: rargs.element.tag },\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            const moduleResult = await coreModuleResolution.binder(bctx, args);\n            const result = moduleResult.result.exports[componentAliasCoreInstanceExport.name];\n            const binderResult = {\n                result\n            };\n            if (isDebug)\n                binderResult['bargs'] = bargs;\n            if (isDebug)\n                binderResult['moduleResult'] = moduleResult;\n            if (isDebug)\n                binderResult['fromExportName'] = componentAliasCoreInstanceExport.name;\n            if (isDebug)\n                binderResult['fromCoreInstanceIndex'] = coreInstanceIndex;\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=core-exports.js.map","import { debugStack, isDebug, jsco_assert } from '../utils/assert';\nimport { createFunctionLifting } from './binding';\nimport { resolveCoreFunction } from './core-functions';\nexport const resolveComponentFunction = (rctx, rargs) => {\n    const coreInstance = rargs.element;\n    switch (coreInstance.tag) {\n        case \"CanonicalFunctionLift\" /* ModelTag.CanonicalFunctionLift */: return resolveCanonicalFunctionLift(rctx, rargs);\n        case \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */: return resolveComponentAliasInstanceExport(rctx, rargs);\n        default: throw new Error(`\"${coreInstance.tag}\" not implemented`);\n    }\n};\nexport const resolveCanonicalFunctionLift = (rctx, rargs) => {\n    const canonicalFunctionLift = rargs.element;\n    jsco_assert(canonicalFunctionLift && canonicalFunctionLift.tag == \"CanonicalFunctionLift\" /* ModelTag.CanonicalFunctionLift */, () => `Wrong element type '${canonicalFunctionLift?.tag}'`);\n    const coreFuntion = rctx.indexes.coreFunctions[canonicalFunctionLift.core_func_index];\n    const coreFunctionResolution = resolveCoreFunction(rctx, { element: coreFuntion, callerElement: canonicalFunctionLift });\n    const sectionFunType = rctx.indexes.componentTypes[canonicalFunctionLift.type_index];\n    jsco_assert(sectionFunType.tag === \"ComponentTypeFunc\" /* ModelTag.ComponentTypeFunc */, () => `expected ComponentTypeFunc, got ${sectionFunType.tag}`);\n    // TODO canonicalFunctionLift.options\n    const liftingBinder = createFunctionLifting(rctx, sectionFunType);\n    return {\n        callerElement: rargs.callerElement,\n        element: canonicalFunctionLift,\n        binder: async (bctx, bargs) => {\n            const args = {\n                arguments: bargs.arguments,\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            const functionResult = await coreFunctionResolution.binder(bctx, args);\n            const jsFunction = liftingBinder(bctx, functionResult.result);\n            const binderResult = {\n                // missingRes: rargs.element.tag,\n                result: jsFunction\n            };\n            if (isDebug)\n                binderResult['bargs'] = bargs;\n            return binderResult;\n        }\n    };\n};\nexport const resolveComponentAliasInstanceExport = (rctx, rargs) => {\n    const componentAliasInstanceExport = rargs.element;\n    jsco_assert(componentAliasInstanceExport && componentAliasInstanceExport.tag == \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */, () => `Wrong element type '${componentAliasInstanceExport?.tag}'`);\n    if (componentAliasInstanceExport.kind === \"type\" /* ComponentExternalKind.Type */) {\n        // TODO types\n        return {\n            callerElement: rargs.callerElement,\n            element: componentAliasInstanceExport,\n            binder: async (bctx, bargs) => {\n                const binderResult = {\n                    missingRes: rargs.element.tag,\n                    confused: 1,\n                    result: {\n                        missingResTypes: rargs.element.tag,\n                    }\n                };\n                if (isDebug)\n                    binderResult['bargs'] = bargs;\n                return binderResult;\n            }\n        };\n    }\n    if (componentAliasInstanceExport.kind !== \"func\" /* ComponentExternalKind.Func */) {\n        throw new Error(`\"${componentAliasInstanceExport.kind}\" not implemented`);\n    }\n    //componentAliasInstanceExport.instance_index;\n    //componentAliasInstanceExport.name;\n    //componentAliasInstanceExport.kind;\n    //const instance = rctx.indexes.componentInstances[componentAliasInstanceExport.instance_index];\n    //const instanceResolution = resolveComponentInstance(rctx, { element: instance, callerElement: componentAliasInstanceExport });\n    return {\n        callerElement: rargs.callerElement,\n        element: componentAliasInstanceExport,\n        binder: async (bctx, bargs) => {\n            const args = {\n                arguments: bargs.arguments,\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            // const moduleResult = await instanceResolution.binder(bctx, args);\n            // TODO this is very fake, how do it know this ?\n            const fn = bargs.arguments['import-func-run'] ?? bargs.arguments['hello:city/city']['sendMessage'];\n            const binderResult = {\n                missingRes: rargs.element.tag,\n                confused: 3,\n                result: fn\n            };\n            if (isDebug)\n                binderResult['bargs'] = bargs;\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=component-functions.js.map","import { debugStack, isDebug, jsco_assert } from '../utils/assert';\nimport { resolveComponentExport } from './component-exports';\nimport { resolveComponentAliasInstanceExport } from './component-functions';\nexport const resolveComponentType = (rctx, rargs) => {\n    const coreInstance = rargs.element;\n    if (!coreInstance) {\n        throw new Error('Wrong element type ');\n    }\n    switch (coreInstance.tag) {\n        case \"ComponentSection\" /* ModelTag.ComponentSection */: return resolveComponentSection(rctx, rargs);\n        case \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */: return resolveComponentAliasInstanceExport(rctx, rargs);\n        default: throw new Error(`\"${coreInstance.tag}\" not implemented`);\n    }\n};\nexport const resolveComponentSection = (rctx, rargs) => {\n    const componentSection = rargs.element;\n    jsco_assert(componentSection && componentSection.tag == \"ComponentSection\" /* ModelTag.ComponentSection */, () => `Wrong element type '${componentSection?.tag}'`);\n    const exportResolutions = [];\n    // const importResolutions: ResolverRes<WITSection, any, any>[] = [];\n    for (const declaration of componentSection.sections) {\n        switch (declaration.tag) {\n            case \"ComponentExport\" /* ModelTag.ComponentExport */: {\n                const exportResolution = resolveComponentExport(rctx, { element: declaration, callerElement: declaration });\n                exportResolutions.push(exportResolution);\n                break;\n            }\n            case \"ComponentImport\" /* ModelTag.ComponentImport */: {\n                /* TODO types ?\n                const importResolution = resolveComponentImport(rctx, { element: declaration, callerElement: declaration });\n                importResolutions.push(importResolution);\n                */\n                break;\n            }\n            case \"ComponentTypeFunc\" /* ModelTag.ComponentTypeFunc */:\n            case \"ComponentTypeDefinedRecord\" /* ModelTag.ComponentTypeDefinedRecord */:\n            case \"ComponentTypeDefinedTuple\" /* ModelTag.ComponentTypeDefinedTuple */:\n            case \"ComponentTypeDefinedEnum\" /* ModelTag.ComponentTypeDefinedEnum */:\n            case \"ComponentTypeDefinedVariant\" /* ModelTag.ComponentTypeDefinedVariant */:\n                // TODO types\n                break;\n            default:\n                throw new Error(`${declaration.tag} not implemented`);\n        }\n    }\n    return {\n        callerElement: rargs.callerElement,\n        element: componentSection,\n        binder: async (bctx, bargs) => {\n            const exports = {};\n            for (const exportResolution of exportResolutions) {\n                const callerElement = exportResolution.callerElement;\n                const args = {\n                    arguments: bargs.arguments,\n                    callerArgs: bargs,\n                    debugSource: callerElement.tag + ':' + callerElement.name.name\n                };\n                debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n                debugStack(args, args, callerElement.tag + ':' + callerElement.name.name);\n                const argResult = await exportResolution.binder(bctx, args);\n                exports[callerElement.name.name] = argResult.result;\n            }\n            /* TODO types ?\n            const imports = {} as any;\n            for (const importResolution of importResolutions) {\n                const callerElement = importResolution.callerElement as ComponentImport;\n                const args = {\n                    arguments: bargs.arguments,\n                    callerArgs: bargs,\n                };\n                debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n                debugStack(args, args, callerElement.tag + ':' + callerElement.name.name);\n\n                const argResult = await importResolution.binder(bctx, args);\n                imports[callerElement.name.name] = argResult.result as any;\n            }\n            */\n            const binderResult = {\n                result: {\n                    ...exports\n                }\n            };\n            if (isDebug)\n                binderResult['arguments'] = bargs;\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=component-types.js.map","import { debugStack, isDebug, jsco_assert } from '../utils/assert';\nimport { resolveComponentFunction } from './component-functions';\nimport { resolveComponentType } from './component-types';\nexport const resolveComponentInstance = (rctx, rargs) => {\n    const coreInstance = rargs.element;\n    switch (coreInstance.tag) {\n        case \"ComponentInstanceInstantiate\" /* ModelTag.ComponentInstanceInstantiate */: return resolveComponentInstanceInstantiate(rctx, rargs);\n        case \"ComponentInstanceFromExports\" /* ModelTag.ComponentInstanceFromExports */: return resolveComponentInstanceFromExports(rctx, rargs);\n        case \"ComponentTypeInstance\" /* ModelTag.ComponentTypeInstance */: return resolveComponentTypeInstance(rctx, rargs);\n        default: throw new Error(`\"${coreInstance.tag}\" not implemented`);\n    }\n};\nexport const resolveComponentInstanceInstantiate = (rctx, rargs) => {\n    const componentInstanceInstantiate = rargs.element;\n    jsco_assert(componentInstanceInstantiate && componentInstanceInstantiate.tag == \"ComponentInstanceInstantiate\" /* ModelTag.ComponentInstanceInstantiate */, () => `Wrong element type '${componentInstanceInstantiate?.tag}'`);\n    const componentSectionIndex = componentInstanceInstantiate.component_index;\n    const componentSection = rctx.indexes.componentTypes[componentSectionIndex];\n    const componentSectionResolution = resolveComponentType(rctx, { element: componentSection, callerElement: componentInstanceInstantiate });\n    const argResolutions = [];\n    for (const arg of componentInstanceInstantiate.args) {\n        switch (arg.kind) {\n            case \"func\" /* ComponentExternalKind.Func */: {\n                const componentFunction = rctx.indexes.componentFunctions[arg.index];\n                const resolver = resolveComponentFunction(rctx, { element: componentFunction, callerElement: arg });\n                argResolutions.push(resolver);\n                break;\n            }\n            case \"instance\" /* ComponentExternalKind.Instance */: {\n                const componentInstance = rctx.indexes.componentInstances[arg.index];\n                const resolver = resolveComponentInstance(rctx, { element: componentInstance, callerElement: arg });\n                argResolutions.push(resolver);\n                break;\n            }\n            case \"type\" /* ComponentExternalKind.Type */: {\n                // const componentType = rctx.indexes.componentTypes[arg.index];\n                // TODO types\n                //const resolver = resolveComponentType(rctx, { element: componentType, callerElement: arg });\n                //resolvers.push(resolver as any);\n                break;\n            }\n            case \"component\" /* ComponentExternalKind.Component */:\n            case \"module\" /* ComponentExternalKind.Module */:\n            case \"value\" /* ComponentExternalKind.Value */:\n            default:\n                throw new Error(`\"${arg.kind}\" not implemented`);\n        }\n    }\n    return {\n        callerElement: rargs.callerElement,\n        element: componentInstanceInstantiate,\n        binder: async (bctx, bargs) => {\n            const componentArgs = {};\n            for (const argResolution of argResolutions) {\n                const callerElement = argResolution.callerElement;\n                const args = {\n                    arguments: bargs.arguments,\n                    callerArgs: bargs,\n                };\n                debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n                debugStack(args, args, 'ComponentInstantiationArg:' + callerElement.index + ':' + callerElement.name);\n                const argResult = await argResolution.binder(bctx, args);\n                componentArgs[callerElement.name] = argResult.result;\n                if (isDebug)\n                    componentArgs['arguments-of:' + callerElement.name] = bargs;\n            }\n            const args = {\n                arguments: componentArgs,\n                callerArgs: bargs,\n            };\n            debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n            const componentSectionResult = await componentSectionResolution.binder(bctx, args);\n            const binderResult = {\n                result: componentSectionResult.result\n            };\n            if (isDebug)\n                binderResult['bargs'] = bargs;\n            return binderResult;\n        }\n    };\n};\nexport const resolveComponentInstanceFromExports = (rctx, rargs) => {\n    const componentInstanceFromExports = rargs.element;\n    jsco_assert(componentInstanceFromExports && componentInstanceFromExports.tag == \"ComponentInstanceFromExports\" /* ModelTag.ComponentInstanceFromExports */, () => `Wrong element type '${componentInstanceFromExports?.tag}'`);\n    throw new Error('TODO');\n    /*\n        const exportResolutions: ResolverRes<ComponentExport, any, JsInterfaceCollection>[] = [];\n        for (const exp of componentInstanceFromExports.exports) {\n            switch (exp.kind) {\n                case ComponentExternalKind.Func: {\n                    const exportResolution = resolveComponentExport(rctx, { element: exp, callerElement: exp });\n                    exportResolutions.push(exportResolution);\n                    break;\n                }\n                default:\n                    throw new Error(`\"${exp.kind}\" not implemented`);\n            }\n        }\n    \n        return {\n            callerElement: rargs.callerElement,\n            element: componentInstanceFromExports,\n            binder: async (bctx, bargs) => {\n                const exports = {} as JsInterfaceCollection;\n                for (const exportResolution of exportResolutions) {\n                    const callerElement = exportResolution.callerElement as ComponentExport;\n                    const args = {\n                        arguments: { missingArgxx: rargs.element.tag },\n                        callerArgs: bargs,\n                    };\n                    debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.selfSortIndex);\n                    debugStack(args, args, 'ComponentInstanceFromExports:'+callerElement.index + ':' + callerElement.name);\n\n                    const argResult = await exportResolution.binder(bctx, args);\n                    exports[callerElement.name.name] = argResult.result as any;\n                }\n                const binderResult: BinderRes<JsInterfaceCollection> = {\n                    result: {\n                        ...exports,\n                        missingRes: rargs.element.tag\n                    } as any as JsInterfaceCollection\n                };\n                if (isDebug) (binderResult as any)['arguments'] = bargs;\n                return binderResult;\n    \n            }\n        };*/\n};\nexport const resolveComponentTypeInstance = (rctx, rargs) => {\n    const componentTypeInstance = rargs.element;\n    jsco_assert(componentTypeInstance && componentTypeInstance.tag == \"ComponentTypeInstance\" /* ModelTag.ComponentTypeInstance */, () => `Wrong element type '${componentTypeInstance?.tag}'`);\n    for (const decl of componentTypeInstance.declarations) {\n        switch (decl.tag) {\n            case \"InstanceTypeDeclarationType\" /* ModelTag.InstanceTypeDeclarationType */: {\n                // TODO types\n                break;\n            }\n            case \"InstanceTypeDeclarationExport\" /* ModelTag.InstanceTypeDeclarationExport */: {\n                switch (decl.ty.tag) {\n                    case \"ComponentTypeRefType\" /* ModelTag.ComponentTypeRefType */: {\n                        // TODO types\n                        break;\n                    }\n                    case \"ComponentTypeRefFunc\" /* ModelTag.ComponentTypeRefFunc */: {\n                        // TODO types\n                        //decl.name;\n                        //decl.ty;\n                        //decl.ty.value;\n                        break;\n                    }\n                    default: throw new Error(`\"${decl.ty.tag}\" not implemented`);\n                }\n                break;\n            }\n            case \"InstanceTypeDeclarationCoreType\" /* ModelTag.InstanceTypeDeclarationCoreType */:\n            case \"InstanceTypeDeclarationAlias\" /* ModelTag.InstanceTypeDeclarationAlias */:\n            default: throw new Error(`\"${decl.tag}\" not implemented`);\n        }\n    }\n    return {\n        callerElement: rargs.callerElement,\n        element: componentTypeInstance,\n        binder: async (bctx, bargs) => {\n            const binderResult = {\n                missingRes: rargs.element.tag,\n                result: {\n                    missingResRes: rargs.element.tag,\n                    confused: 2\n                }\n            };\n            if (isDebug)\n                binderResult['bargs'] = bargs;\n            return binderResult;\n        }\n    };\n};\n//# sourceMappingURL=component-instances.js.map","import { debugStack, isDebug, jsco_assert } from '../utils/assert';\nimport { resolveComponentFunction } from './component-functions';\nimport { resolveComponentInstance } from './component-instances';\nimport { resolveComponentType } from './component-types';\nexport const resolveComponentExport = (rctx, rargs) => {\n    const componentExport = rargs.element;\n    jsco_assert(componentExport && componentExport.tag == \"ComponentExport\" /* ModelTag.ComponentExport */, () => `Wrong element type '${componentExport?.tag}'`);\n    // TODO componentExport.ty ?\n    switch (componentExport.kind) {\n        case \"func\" /* ComponentExternalKind.Func */: {\n            const func = rctx.indexes.componentFunctions[componentExport.index];\n            const functionResolution = resolveComponentFunction(rctx, { element: func, callerElement: componentExport });\n            return {\n                callerElement: rargs.callerElement,\n                element: componentExport,\n                binder: async (bctx, bargs) => {\n                    const args = {\n                        arguments: bargs.arguments,\n                        callerArgs: bargs,\n                    };\n                    debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.name.name + ':' + rargs.element.kind);\n                    const exportResult = await functionResolution.binder(bctx, args);\n                    const binderResult = {\n                        // missingRes: rargs.element.tag,\n                        result: exportResult.result\n                    };\n                    if (isDebug)\n                        binderResult['bargs'] = bargs;\n                    if (isDebug)\n                        binderResult['exportResult'] = exportResult;\n                    return binderResult;\n                }\n            };\n        }\n        case \"instance\" /* ComponentExternalKind.Instance */: {\n            const instance = rctx.indexes.componentInstances[componentExport.index];\n            const instanceResolution = resolveComponentInstance(rctx, { element: instance, callerElement: componentExport });\n            return {\n                callerElement: rargs.callerElement,\n                element: componentExport,\n                binder: async (bctx, bargs) => {\n                    const args = {\n                        arguments: bargs.arguments,\n                        callerArgs: bargs,\n                    };\n                    debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.name.name + ':' + rargs.element.kind);\n                    const instanceResult = await instanceResolution.binder(bctx, args);\n                    const ifc = {};\n                    ifc[componentExport.name.name] = instanceResult.result;\n                    const binderResult = {\n                        // missingRes: rargs.element.tag,\n                        result: ifc\n                    };\n                    if (isDebug)\n                        binderResult['bargs'] = bargs;\n                    if (isDebug)\n                        binderResult['exportResult'] = instanceResult;\n                    return binderResult;\n                }\n            };\n        }\n        case \"type\" /* ComponentExternalKind.Type */: {\n            const type = rctx.indexes.componentTypes[componentExport.index];\n            const typeResolution = resolveComponentType(rctx, { element: type, callerElement: componentExport });\n            return {\n                callerElement: rargs.callerElement,\n                element: componentExport,\n                binder: async (bctx, bargs) => {\n                    const args = {\n                        arguments: bargs.arguments,\n                        callerArgs: bargs,\n                    };\n                    debugStack(bargs, args, rargs.element.tag + ':' + rargs.element.name.name + ':' + rargs.element.kind);\n                    const exportResult = await typeResolution.binder(bctx, args);\n                    const ifc = {};\n                    ifc[componentExport.name.name] = exportResult.result;\n                    const binderResult = {\n                        // missingRes: rargs.element.tag,\n                        result: ifc\n                    };\n                    if (isDebug)\n                        binderResult['bargs'] = bargs;\n                    if (isDebug)\n                        binderResult['exportResult'] = exportResult;\n                    return binderResult;\n                }\n            };\n        }\n        case \"component\" /* ComponentExternalKind.Component */:\n        case \"module\" /* ComponentExternalKind.Module */:\n        case \"value\" /* ComponentExternalKind.Value */:\n        default:\n            throw new Error(`${componentExport.kind} not implemented`);\n    }\n};\n//# sourceMappingURL=component-exports.js.map","import { configuration } from '../utils/assert';\nexport function createResolverContext(sections, options) {\n    const rctx = {\n        usesNumberForInt64: (options.useNumberForInt64 === true) ? true : false,\n        wasmInstantiate: options.wasmInstantiate ?? WebAssembly.instantiate,\n        indexes: {\n            componentExports: [],\n            componentImports: [],\n            componentFunctions: [],\n            componentInstances: [],\n            componentTypes: [],\n            componentTypeResource: [],\n            coreModules: [],\n            coreInstances: [],\n            coreFunctions: [],\n            coreMemories: [],\n            coreTables: [],\n            coreGlobals: [],\n            componentSections: [],\n        },\n    };\n    const indexes = rctx.indexes;\n    for (const section of sections) {\n        // TODO: process all sections into model\n        const bucket = bucketByTag(rctx, section.tag, false, section.kind);\n        bucket.push(section);\n    }\n    // indexed with imports first and then function definitions next\n    // See https://github.com/bytecodealliance/wasm-interface-types/blob/main/BINARY.md\n    rctx.indexes.componentTypes = [...rctx.indexes.componentSections, ...indexes.componentTypes];\n    setSelfIndex(rctx);\n    return rctx;\n}\nexport function setSelfIndex(rctx) {\n    function setSelfIndex(sort) {\n        for (let i = 0; i < sort.length; i++) {\n            sort[i].selfSortIndex = i;\n        }\n    }\n    setSelfIndex(rctx.indexes.componentExports);\n    setSelfIndex(rctx.indexes.componentImports);\n    setSelfIndex(rctx.indexes.componentFunctions);\n    setSelfIndex(rctx.indexes.componentInstances);\n    setSelfIndex(rctx.indexes.componentTypes);\n    setSelfIndex(rctx.indexes.componentTypeResource);\n    setSelfIndex(rctx.indexes.coreModules);\n    setSelfIndex(rctx.indexes.coreInstances);\n    setSelfIndex(rctx.indexes.coreFunctions);\n    setSelfIndex(rctx.indexes.coreMemories);\n    setSelfIndex(rctx.indexes.coreTables);\n    setSelfIndex(rctx.indexes.coreGlobals);\n}\nexport function createBindingContext(rctx, componentImports) {\n    let memory = undefined;\n    let cabi_realloc = undefined;\n    function initializeMemory(m) {\n        memory = m;\n    }\n    function initializeRealloc(realloc) {\n        cabi_realloc = realloc;\n    }\n    function getView(pointer, len) {\n        return new DataView(memory.buffer, pointer, len);\n    }\n    function getViewU8(pointer, len) {\n        return new Uint8Array(memory.buffer, pointer, len);\n    }\n    function getMemory() {\n        return memory;\n    }\n    function realloc(oldPtr, oldSize, align, newSize) {\n        return cabi_realloc(oldPtr, oldSize, align, newSize);\n    }\n    function alloc(newSize, align) {\n        return cabi_realloc(0, 0, align, newSize);\n    }\n    function readI32(ptr) {\n        return getView().getInt32(ptr);\n    }\n    function writeI32(ptr, value) {\n        return getView().setInt32(ptr, value);\n    }\n    function abort() {\n        throw new Error('not implemented');\n    }\n    const ctx = {\n        componentImports,\n        coreInstances: [],\n        componentInstances: [],\n        utf8Decoder: new TextDecoder(),\n        utf8Encoder: new TextEncoder(),\n        initializeMemory,\n        initializeRealloc,\n        getView,\n        getViewU8,\n        getMemory,\n        realloc,\n        alloc,\n        readI32,\n        writeI32,\n        abort,\n    };\n    if (configuration === 'Debug') {\n        ctx.debugStack = [];\n    }\n    return ctx;\n}\nexport function bucketByTag(rctx, tag, read, kind) {\n    switch (tag) {\n        case \"CoreModule\" /* ModelTag.CoreModule */:\n            return rctx.indexes.coreModules;\n        case \"ComponentExport\" /* ModelTag.ComponentExport */:\n            return rctx.indexes.componentExports;\n        case \"ComponentImport\" /* ModelTag.ComponentImport */:\n            return rctx.indexes.componentImports;\n            break;\n        case \"ComponentAliasCoreInstanceExport\" /* ModelTag.ComponentAliasCoreInstanceExport */: {\n            switch (kind) {\n                case \"func\" /* ExternalKind.Func */:\n                    return rctx.indexes.coreFunctions;\n                case \"table\" /* ExternalKind.Table */:\n                    return rctx.indexes.coreTables;\n                case \"memory\" /* ExternalKind.Memory */:\n                    return rctx.indexes.coreMemories;\n                case \"global\" /* ExternalKind.Global */:\n                    return rctx.indexes.coreGlobals;\n                case \"tag\" /* ExternalKind.Tag */:\n                default:\n                    throw new Error(`unexpected section tag: ${kind}`);\n            }\n            break;\n        }\n        case \"ComponentAliasInstanceExport\" /* ModelTag.ComponentAliasInstanceExport */: {\n            switch (kind) {\n                case \"func\" /* ComponentExternalKind.Func */:\n                    return rctx.indexes.componentFunctions;\n                case \"component\" /* ComponentExternalKind.Component */:\n                    return rctx.indexes.componentTypes;\n                case \"type\" /* ComponentExternalKind.Type */:\n                    return rctx.indexes.componentTypes;\n                case \"module\" /* ComponentExternalKind.Module */:\n                case \"value\" /* ComponentExternalKind.Value */:\n                case \"instance\" /* ComponentExternalKind.Instance */:\n                default:\n                    throw new Error(`unexpected section tag: ${kind}`);\n            }\n        }\n        case \"CoreInstanceFromExports\" /* ModelTag.CoreInstanceFromExports */:\n        case \"CoreInstanceInstantiate\" /* ModelTag.CoreInstanceInstantiate */:\n            return rctx.indexes.coreInstances;\n        case \"ComponentInstanceFromExports\" /* ModelTag.ComponentInstanceFromExports */:\n        case \"ComponentInstanceInstantiate\" /* ModelTag.ComponentInstanceInstantiate */:\n            return rctx.indexes.componentInstances;\n        case \"ComponentTypeFunc\" /* ModelTag.ComponentTypeFunc */:\n            return rctx.indexes.componentTypes;\n        case \"ComponentSection\" /* ModelTag.ComponentSection */:\n            return read\n                ? rctx.indexes.componentTypes\n                : rctx.indexes.componentSections; //append later\n        case \"ComponentTypeDefinedBorrow\" /* ModelTag.ComponentTypeDefinedBorrow */:\n        case \"ComponentTypeDefinedEnum\" /* ModelTag.ComponentTypeDefinedEnum */:\n        case \"ComponentTypeDefinedFlags\" /* ModelTag.ComponentTypeDefinedFlags */:\n        case \"ComponentTypeDefinedList\" /* ModelTag.ComponentTypeDefinedList */:\n        case \"ComponentTypeDefinedOption\" /* ModelTag.ComponentTypeDefinedOption */:\n        case \"ComponentTypeDefinedOwn\" /* ModelTag.ComponentTypeDefinedOwn */:\n        case \"ComponentTypeDefinedPrimitive\" /* ModelTag.ComponentTypeDefinedPrimitive */:\n        case \"ComponentTypeDefinedRecord\" /* ModelTag.ComponentTypeDefinedRecord */:\n        case \"ComponentTypeDefinedResult\" /* ModelTag.ComponentTypeDefinedResult */:\n        case \"ComponentTypeDefinedTuple\" /* ModelTag.ComponentTypeDefinedTuple */:\n        case \"ComponentTypeDefinedVariant\" /* ModelTag.ComponentTypeDefinedVariant */:\n            return rctx.indexes.componentTypes;\n        case \"ComponentTypeInstance\" /* ModelTag.ComponentTypeInstance */:\n            return rctx.indexes.componentInstances;\n        case \"ComponentTypeResource\" /* ModelTag.ComponentTypeResource */:\n            return rctx.indexes.componentTypeResource;\n        case \"CanonicalFunctionLower\" /* ModelTag.CanonicalFunctionLower */: {\n            return rctx.indexes.coreFunctions;\n        }\n        case \"CanonicalFunctionLift\" /* ModelTag.CanonicalFunctionLift */: {\n            return rctx.indexes.componentFunctions;\n        }\n        case \"SkippedSection\" /* ModelTag.SkippedSection */:\n        case \"CustomSection\" /* ModelTag.CustomSection */:\n            return []; //drop\n        case \"ComponentAliasOuter\" /* ModelTag.ComponentAliasOuter */:\n        case \"CanonicalFunctionResourceDrop\" /* ModelTag.CanonicalFunctionResourceDrop */:\n        case \"CanonicalFunctionResourceNew\" /* ModelTag.CanonicalFunctionResourceNew */:\n        case \"CanonicalFunctionResourceRep\" /* ModelTag.CanonicalFunctionResourceRep */:\n        default:\n            throw new Error(`unexpected section tag: ${tag}`);\n    }\n}\nexport function elementByIndex(rctx, template, index) {\n    const bucket = bucketByTag(rctx, template.tag, true, template.kind);\n    return bucket[index];\n}\n//# sourceMappingURL=context.js.map","import { parse } from '../parser';\nimport { isDebug } from '../utils/assert';\nimport { resolveComponentExport } from './component-exports';\nimport { createBindingContext, createResolverContext } from './context';\nimport { resolveCoreInstance } from './core-instance';\nexport async function instantiateComponent(modelOrComponentOrUrl, imports, options) {\n    let input = modelOrComponentOrUrl;\n    if (typeof input !== 'object' || (Array.isArray(input) && input.length != 0 && typeof input[0] !== 'object')) {\n        input = await parse(input, options ?? {});\n    }\n    const component = await createComponent(input, options);\n    return component.instantiate(imports);\n}\nexport async function createComponent(modelOrComponentOrUrl, options) {\n    let input = modelOrComponentOrUrl;\n    if (typeof input !== 'object' || (Array.isArray(input) && input.length != 0 && typeof input[0] !== 'object')) {\n        input = await parse(input, options ?? {});\n    }\n    const rctx = createResolverContext(input, options ?? {});\n    for (const coreModule of rctx.indexes.coreModules) {\n        await coreModule.module;\n    }\n    const coreInstanceResolutions = [];\n    for (const coreInstance of rctx.indexes.coreInstances) {\n        const resolution = resolveCoreInstance(rctx, { element: coreInstance, callerElement: undefined });\n        coreInstanceResolutions.push(resolution);\n    }\n    /*const componentImportResolutions: ResolverRes<TaggedElement, JsInterfaceCollection, JsInterfaceCollection>[] = [];\n    for (const componentExport of rctx.indexes.componentImports) {\n        const resolution = resolveComponentImport(rctx, { element: componentExport, callerElement: undefined });\n        componentImportResolutions.push(resolution);\n    }*/\n    const componentExportResolutions = [];\n    for (const componentExport of rctx.indexes.componentExports) {\n        const resolution = resolveComponentExport(rctx, { element: componentExport, callerElement: undefined });\n        componentExportResolutions.push(resolution);\n    }\n    async function instantiate(componentImports) {\n        componentImports = componentImports ?? {};\n        const ctx = createBindingContext(rctx, componentImports);\n        const exports = {};\n        /*const imports = {};\n        for (const componentImportResolution of componentImportResolutions) {\n            const args = {\n                arguments: componentImports\n            };\n            if (isDebug) (args as any)['debugStack'] = [];\n            const componentExportResult = await componentImportResolution.binder(ctx, args);\n            Object.assign(imports, componentExportResult.result);\n        }*/\n        for (const componentExportResolution of componentExportResolutions) {\n            const args = {\n                arguments: componentImports\n            };\n            if (isDebug)\n                args['debugStack'] = [];\n            const componentExportResult = await componentExportResolution.binder(ctx, args);\n            Object.assign(exports, componentExportResult.result);\n        }\n        // this is magic, because some core instances are not exported, but they are still needed\n        // I think this is about $imports\n        for (const instanceResolution of coreInstanceResolutions) {\n            const args = {\n                arguments: componentImports\n            };\n            if (isDebug)\n                args['debugStack'] = [];\n            await instanceResolution.binder(ctx, args);\n        }\n        return {\n            exports,\n            abort: ctx.abort,\n        };\n    }\n    const component = {\n        resolverContext: rctx,\n        instantiate,\n    };\n    return component;\n}\n//# sourceMappingURL=index.js.map","// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"./.types.d.ts\" />\nimport gitHash from 'env:gitHash';\nimport configuration from 'env:configuration';\nimport { setConfiguration } from './utils/assert';\nexport { parse } from './parser';\nexport { instantiateComponent, createComponent } from './resolver';\nexport { createLifting, createLowering } from './resolver/binding';\nexport function getBuildInfo() {\n    return {\n        gitHash,\n        configuration,\n    };\n}\nsetConfiguration(configuration);\n//# sourceMappingURL=index.js.map"],"names":["jsco_assert","condition","messageFactory","message","Error","configuration","isDebug","debugStack","src","target","position","orig","isNode","process","versions","node","async","getBodyIfResponse","input","body","StreamSource","total","bpos","buf","reader","constructor","stream","this","getReader","pos","fill","need","length","result","read","done","value","start","len","Math","min","subarray","readAvailable","limit","eof","maybebuf","readExact","n","r","Uint8Array","rest","set","skip","subSource","SubSource","subSyncSource","SyncArraySource","close","releaseLock","ArraySource","_pos","items","from","byteLength","Promise","resolve","max","e","reject","delegate","data","checkLimit","needs","remaining","UnsupportedOperationError","prefix","suffix","msg","undefined","super","defError","SEMAPHORE","Symbol","NO_OP","ensureTransducer","x","fn","implementsFunction","xform","Reduced","val","deref","isReduced","unreduced","iterator1","xs","reduce","_","y","wasm","U8","window","global","inst","WebAssembly","Instance","Module","base64Decode","rfn","bc","bs","compR","acc","reduced","indexOf","exports","memory","buffer","ensureWASM","unsupported","decodeULEB128","op","signed","idx","BigInt","asIntN","asUintN","textDecoder","TextDecoder","readU32Async","source","decoder","i","maxLen","b","push","readRawIntegerAsync","consumed","bits","Number","readIntegerAsync","leb.decodeULEB128","readU32","readRawInteger","readInteger","readStringArray","count","arr","readName","content","decode","parseAsExternalKind","k1","readComponentExternalKind","parseAsComponentExternalKind","k2","toString","readInstanceTypeDeclarations","declarations","declaration","tag","readComponentType","name","readComponentExternName","ty","readComponentTypeRef","type","readDestructor","readComponentInstantiationArgs","args","kind","index","readCoreInstance","module_index","readInstantiationArgs","readExports","readInstantiationArgKind","readCanonicalFunction","controlByte","core_func_index","options","readCanonicalOptions","type_index","func_index","resource","optionsCount","readCanonicalOption","rep","dtor","params","readNamedValues","results","readComponentFuncResult","ok","readComponentValType","err","members","variants","refines","readComponentTypeDefined","readTypeBounds","values","parsePrimitiveValType","parseAsComponentOuterAliasKind","ceil","parseSectionExport","ctx","sections","section","parseModule","size","res","compileStreaming","whileReading","response","resolveWhenDoneReading","pull","controller","copy","slice","enqueue","rs","ReadableStream","headers","Headers","append","Response","status","statusText","toWasmResponse","module","parseAliasTarget","b1","b2","instance_index","WIT_MAGIC","WIT_VERSION","WIT_LAYER","parse","componentOrUrl","url","isFileUrl","startsWith","isHttpUrl","import","then","fs","readFile","globalThis","fetch","fetchLike","checkPreamble","otherSectionData","processCustomSection","model","parseSection","s","parseWIT","magic","version","layer","every","v","asyncSub","sub","nameSize","parseSectionCustom","coreInstances","coreInstance","parseSectionCoreInstance","end","parseSectionComponent","component_index","parseSectionInstance","aliases","alias","parseSectionAlias","parseSectionType","canonFunctions","canonicalFun","parseSectionCanon","parseSectionImport","skipSection","absoluteActual","absoluteExpected","hex","t","padStart","bufferToHex","JSON","stringify","memoizeCache","Map","memoize","key","factory","get","createLowering","rctx","typeModel","pointer","view","getView","utf8Decoder","spill","createStringLowering","createLifting","srcJsValue","str","TypeError","allocLen","ptr","writtenTotal","realloc","written","utf8Encoder","encodeInto","getViewU8","usesNumberForInt64","num","resolved","indexes","componentInstances","recordModel","lifters","member","lifter","srcJsRecord","wasmValue","createRecordLifting","componentTypes","resolveCoreInstance","rargs","element","resolveCoreInstanceFromExports","resolveCoreInstanceInstantiate","coreInstanceFromExports","exportResolutions","exp","func","coreFunctions","exportResolution","resolveCoreFunction","callerElement","table","coreTables","binder","bctx","bargs","arguments","callerArgs","selfSortIndex","argResult","binderResult","coreInstanceInstantiate","coreModuleIndex","coreModuleResolution","coreModule","coreInstanceIndex","instance","wasmInstantiate","initializeMemory","cabi_realloc","initializeRealloc","resolveCoreModule","coreModules","argResolutions","arg","argInstance","resolution","wasmImports","debugSource","argResolution","aaa","moduleResult","componentAliasCoreInstanceExport","missingArgEx","resolveComponentAliasCoreInstanceExport","resolveCanonicalFunctionLower","canonicalFunctionLowerElem","componentFuntion","componentFunctions","componentFunctionResolution","resolveComponentFunction","loweringBinder","exportModel","jsFunction","paramLowerers","param","lowerer","resultLifters","covertedArgs","converted","resJs","createFunctionLowering","functionResult","resolveCanonicalFunctionLift","resolveComponentAliasInstanceExport","canonicalFunctionLift","coreFuntion","coreFunctionResolution","sectionFunType","liftingBinder","importModel","paramLifters","resultLowerers","wasmFunction","createFunctionLifting","componentAliasInstanceExport","missingRes","confused","missingResTypes","resolveComponentType","resolveComponentSection","componentSection","resolveComponentExport","resolveComponentInstance","resolveComponentInstanceInstantiate","resolveComponentInstanceFromExports","resolveComponentTypeInstance","componentInstanceInstantiate","componentSectionIndex","componentSectionResolution","componentFunction","resolver","componentInstance","componentArgs","componentInstanceFromExports","componentTypeInstance","decl","missingResRes","componentExport","functionResolution","exportResult","instanceResolution","instanceResult","ifc","typeResolution","bucketByTag","componentExports","componentImports","coreMemories","coreGlobals","componentSections","componentTypeResource","instantiateComponent","modelOrComponentOrUrl","imports","Array","isArray","createComponent","instantiate","useNumberForInt64","setSelfIndex","sort","createResolverContext","coreInstanceResolutions","componentExportResolutions","resolverContext","DataView","TextEncoder","m","getMemory","oldPtr","oldSize","align","newSize","alloc","readI32","getInt32","writeI32","setInt32","abort","createBindingContext","componentExportResolution","componentExportResult","Object","assign","getBuildInfo","gitHash"],"mappings":"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","x_google_ignoreList":[3,4,5,6,7,8,9,10,11,12,13,14]}